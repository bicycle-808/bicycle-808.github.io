<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>八股文：Java</title>
      <link href="/2023/08/23/%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%9AJava/"/>
      <url>/2023/08/23/%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%9AJava/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a600e3bcac1e299ecabfedf36b963b75eaca85be842295145d4761a45605a19d">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f5845928186191ec9691717e38aaf1f6023d11f27d1b690fad82c024e6a2f4f6792d2f361ce5220ce891f77341712592b8cd1307266c617095fcbaa46888c3e908ce69ea9ecfd66f874422dbd8c26c09877e19a1944b23036f8da55416604593f6626da532164437171832a8825800b6694af9a7566be26fd1c8a47e42e6429717f08002aa489c9bf1427003ac285557a769ece1efb07eff92607afcfcf75ff4b62c938994edf97fee0709fcc438e81eb0b77d4e208ccad5bf085aba11c9b63632897bc189bb2c94f0a3a729b94a21cd77cf0079f1f6139649d7a104d3c43e1108fc51d759d22f9a923542c96c3e8b4c85d933cecb414fd183bc69258bf80ea1305e0081ac57ee79deb44170bb2d6f7242e7eca6b711f46a2894be0f91e255ed6b23c69dee76a0468715b823abc3cd4743ba36f4025f14e5b52d6ae273377a4df31498b75fcbedd4ea401a53fb5eb3ff9accdcbd5418e0e8cd2bc8679dc5cfca5b4640dd390397f801017ead3029f83d57d8cade0780d55fcaf0f23ee032116d9d560f5a993ebabf5bcc8b7ea3ceb239cfdf24d5dc4f4a66d419f8a9c22e60af505ce3b986a4808575a4e0ed99428625847145f3a6fb8747379c631a2cb686cea0dcb9e831ef61995af18342246a2123290a4382b6ed9c0a7dc6dbd68a42348d015902010e81db50dbc6e4e2a9c9f0aa81d5fbb1899fc44315c4f2b5fa7d86be05060004e7396199f3cb72a790b81ef66c3777b26deefdccc87e0d2ef500ed87f0695c207e9ec62e1c38da7782693a0e2c469989aa15b32d56121adf18542beebcb7d651d54f913ac9e87a3ebe91d83a0f1a02eaa08baddec25dc4830aa77e3b70eb160ca147b7f24887e04ec151ca776f36cb516ab2f2cd5580c3b1d9f58a47e4f04ee052591b143b831cfe8f14abe201599715b0dd454ffecea2c8624ffe6b5bfc6161aa6c55eb4d7fe938aad4e44c8bf1b3ddaefeaac5e3a774733fc20b30c493229f413ecde6011c78c36eec6fbd01c108d53ae8045bac4588f4250177a02b519a9086b9a8740b0f451caaa6a7b3981f61a5da23a5a6914754fee9e2261553ef376f30b99d833e397c312c0bf80c6bcce850187f9e9c09fd3e85bca41b36cddea2f8e19b655c96a798786a9266d9965bb7100dd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码输入框上描述性内容</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 面试篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源项目 Tengbin_ACM 企业级中央配置引擎</title>
      <link href="/2023/07/26/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%20Tengbin_ACM%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%B8%AD%E5%A4%AE%E9%85%8D%E7%BD%AE%E5%BC%95%E6%93%8E/"/>
      <url>/2023/07/26/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%20Tengbin_ACM%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%B8%AD%E5%A4%AE%E9%85%8D%E7%BD%AE%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本项目是适用于在企业中一同管理多个项目配置信息的中央配置引擎。</p></blockquote><h1 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h1><p>用于统一管理项目中各种配置的平台，是互联网项目开发中必不可少的部分。由于它的存在，可以让我们在开发中减少因配置更新迭代而产生的大量代码。同时，针对成熟的技术从而实现配置热部署，当我们的配置发生变化时，无须停止服务，实现配置的更新。</p><p>采用 <code>SpringBoot + SpringCloud</code> 环境搭建，结合微服务项目引入应用。项目中使用了 <code>Redis + FastDFS</code> 作为缓存和容灾的解决方案。在推送配置时，采用了较流行的推和拉两种模式来实现。并且把配置中心中推送轨迹的功能也加入了进来。</p><h1 id="配置中心作用"><a href="#配置中心作用" class="headerlink" title="配置中心作用"></a>配置中心作用</h1><h2 id="动态加载配置"><a href="#动态加载配置" class="headerlink" title="动态加载配置"></a>动态加载配置</h2><p>？</p><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>？</p><h2 id="微服务架构统一管理配置"><a href="#微服务架构统一管理配置" class="headerlink" title="微服务架构统一管理配置"></a>微服务架构统一管理配置</h2><p>？</p><h2 id="配置更新轨迹"><a href="#配置更新轨迹" class="headerlink" title="配置更新轨迹"></a>配置更新轨迹</h2><p>？</p><h1 id="当前市场上配置中心解决方案介绍"><a href="#当前市场上配置中心解决方案介绍" class="headerlink" title="当前市场上配置中心解决方案介绍"></a>当前市场上配置中心解决方案介绍</h1><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>？</p><h2 id="Ctrip-Apollo"><a href="#Ctrip-Apollo" class="headerlink" title="Ctrip Apollo"></a>Ctrip Apollo</h2><p>？</p><h2 id="Alibaba-Nacos"><a href="#Alibaba-Nacos" class="headerlink" title="Alibaba Nacos"></a>Alibaba Nacos</h2><p>？</p><h2 id="阿里云-ACM服务"><a href="#阿里云-ACM服务" class="headerlink" title="阿里云-ACM服务"></a>阿里云-ACM服务</h2><p>？</p><h2 id="常用配置中心差异"><a href="#常用配置中心差异" class="headerlink" title="常用配置中心差异"></a>常用配置中心差异</h2><p>？</p><h1 id="配置中心技术解决方案分析"><a href="#配置中心技术解决方案分析" class="headerlink" title="配置中心技术解决方案分析"></a>配置中心技术解决方案分析</h1><p>想实现自定义配置中心，有哪些潜在问题呢？或者说从方面考虑呢？</p><ol><li>配置中心的数据如何接入</li><li>配置中心的存储如何落盘</li><li>配置中心的配置更新后如何动态推送</li><li>业务微服务读取配置的方式，如何支撑高并发读取</li><li>配置更新轨迹的实现</li><li>配置中心的监控，高并发下稳定的运行如何实现</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="配置中心数据接入的解决方案"><a href="#配置中心数据接入的解决方案" class="headerlink" title="配置中心数据接入的解决方案"></a>配置中心数据接入的解决方案</h3><p>？</p><h3 id="配置中心的配置存储的解决方案"><a href="#配置中心的配置存储的解决方案" class="headerlink" title="配置中心的配置存储的解决方案"></a>配置中心的配置存储的解决方案</h3><p>？</p><h3 id="配置更新后的动态推送解决方案"><a href="#配置更新后的动态推送解决方案" class="headerlink" title="配置更新后的动态推送解决方案"></a>配置更新后的动态推送解决方案</h3><p>？</p><h3 id="业务微服务高并发读取配置的解决方案"><a href="#业务微服务高并发读取配置的解决方案" class="headerlink" title="业务微服务高并发读取配置的解决方案"></a>业务微服务高并发读取配置的解决方案</h3><p>？</p><h3 id="配置更新轨迹的解决方案"><a href="#配置更新轨迹的解决方案" class="headerlink" title="配置更新轨迹的解决方案"></a>配置更新轨迹的解决方案</h3><p>？</p><h3 id="配置中心运行监控的解决方案"><a href="#配置中心运行监控的解决方案" class="headerlink" title="配置中心运行监控的解决方案"></a>配置中心运行监控的解决方案</h3><p>？</p><h1 id="企业级应用配置管理平台（Tengbin-ACM）"><a href="#企业级应用配置管理平台（Tengbin-ACM）" class="headerlink" title="企业级应用配置管理平台（Tengbin_ACM）"></a>企业级应用配置管理平台（Tengbin_ACM）</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Drools规则引擎原理及实战（一）</title>
      <link href="/2023/07/07/Drools%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/07/07/Drools%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><p>现有一个在线申请信用卡的业务场景，用户需要录入个人信息，如下图所示：</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/image-20200114163727767.png" alt="image-20200114163727767"></p><p>通过上图可以看到，用户录入的个人信息包括姓名、性别、年龄、学历、电话、所在公司、职位、月收入、是否有房、是否有车、是否有信用卡等。录入完成后点击申请按钮提交即可。</p><p>用户提交申请后，需要在系统的服务端进行<strong>用户信息合法性检查</strong>（是否有资格申请信用卡），只有通过合法性检查的用户才可以成功申请到信用卡（注意：不同用户有可能申请到的信用卡额度不同）。</p><p>检查用户信息合法性的规则如下：</p><table><thead><tr><th>规则编号</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>检查学历与薪水1</td><td>如果申请人既没房也没车，同时学历为大专以下，并且月薪少于5000，那么不通过</td></tr><tr><td>2</td><td>检查学历与薪水2</td><td>如果申请人既没房也没车，同时学历为大专或本科，并且月薪少于3000，那么不通过</td></tr><tr><td>3</td><td>检查学历与薪水3</td><td>如果申请人既没房也没车，同时学历为本科以上，并且月薪少于2000，同时之前没有信用卡的，那么不通过</td></tr><tr><td>4</td><td>检查申请人已有的信用卡数量</td><td>如果申请人现有的信用卡数量大于10，那么不通过</td></tr></tbody></table><p>用户信息合法性检查通过后，还需要根据如下<strong>信用卡发放规则</strong>确定用户所办信用卡的额度：</p><table><thead><tr><th>规则编号</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>规则1</td><td>如果申请人有房有车，或者月收入在20000以上，那么发放的信用卡额度为15000</td></tr><tr><td>2</td><td>规则2</td><td>如果申请人没房没车，但月收入在10000~20000之间，那么发放的信用卡额度为6000</td></tr><tr><td>3</td><td>规则3</td><td>如果申请人没房没车，月收入在10000以下，那么发放的信用卡额度为3000</td></tr><tr><td>4</td><td>规则4</td><td>如果申请人有房没车或者没房但有车，月收入在10000以下，那么发放的信用卡额度为5000</td></tr><tr><td>5</td><td>规则5</td><td>如果申请人有房没车或者是没房但有车，月收入在10000~20000之间，那么发放的信用卡额度为8000</td></tr></tbody></table><p>思考：如何实现上面的业务逻辑？</p><p>最容易想到的就是使用分支判断（if else）来实现，例如通过如下代码来检查用户信息合法性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处为伪代码</span></span><br><span class="line"><span class="comment">//检查用户信息合法性，返回true表示检查通过，返回false表示检查不通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUser</span> <span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="comment">//如果申请人既没房也没车，同时学历为大专以下，并且月薪少于5000，那么不通过</span></span><br><span class="line">    <span class="keyword">if</span> (user.getHouse() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getcar() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getEducation().equals(<span class="string">&quot;大专以下&quot;</span>)</span><br><span class="line">            &amp;&amp; user.getSalary &lt; <span class="number">5000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果申请人既没房也没车，同时学历为大专或本科，并且月薪少于3000，那么不通过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (user.getHouse() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getcar() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getEducation().equals(<span class="string">&quot;大专或本科&quot;</span>)</span><br><span class="line">            &amp;&amp; user.getSalary &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果申请人既没房也没车，同时学历为本科以上，并且月薪少于2000，同时之前没有信用卡的，那么不通过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (user.getHouse() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getcar() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getEducation().equals(<span class="string">&quot;本科以上&quot;</span>)</span><br><span class="line">            &amp;&amp; user.getSalary &lt; <span class="number">2000</span></span><br><span class="line">            &amp;&amp; user.getHasCreditCard() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果申请人现有的信用卡数量大于10，那么不通过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (user.getCreditCardCount() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户信息合法性检查通过后，还需要通过如下代码确定用户所办信用卡的额度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处为伪代码</span></span><br><span class="line"><span class="comment">//根据用户输入信息确定信用卡额度</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">determineCreditCardLimit</span> <span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="comment">//如果申请人有房有车，或者月收入在20000以上，那么发放的信用卡额度为15000</span></span><br><span class="line">    <span class="keyword">if</span> ((user.getHouse() != <span class="literal">null</span> &amp;&amp; user.getcar() != <span class="literal">null</span>)</span><br><span class="line">            || user.getSalary() &gt; <span class="number">20000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果申请人没房没车，并且月收入在10000到20000之间，那么发放的信用卡额度为6000</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (user.getHouse() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getcar() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getSalary() &gt; <span class="number">10000</span></span><br><span class="line">            &amp;&amp; user.getSalary() &lt; <span class="number">20000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果申请人没房没车，并且月收入在10000以下，那么发放的信用卡额度为3000</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (user.getHouse() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getcar() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; user.getSalary() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果申请人有房没车或者没房但有车，并且月收入在10000以下，那么发放的信用卡额度为5000</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((((user.getHouse() != <span class="literal">null</span> &amp;&amp; user.getcar() == <span class="literal">null</span>) || (user.getHouse() == <span class="literal">null</span> &amp;&amp; user.getcar() != <span class="literal">null</span>))</span><br><span class="line">            &amp;&amp; user.getSalary() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果申请人有房没车或者没房但有车，并且月收入在10000到20000之间，那么发放的信用卡额度为8000</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((((user.getHouse() != <span class="literal">null</span> &amp;&amp; user.getcar() == <span class="literal">null</span>) || (user.getHouse() == <span class="literal">null</span> &amp;&amp; user.getcar() != <span class="literal">null</span>))</span><br><span class="line">            &amp;&amp; (user.getSalary() &gt; <span class="number">10000</span> &amp;&amp; user.getSalary() &lt; <span class="number">20000</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的伪代码我们可以看到，我们的业务规则是通过 Java 代码的方式实现的。这种实现方式存在如下问题：</p><ol><li>硬编码实现业务规则难以维护</li><li>硬编码实现业务规则难以应对变化</li><li>业务规则发生变化需要修改代码，重启服务后才能生效</li></ol><p>那么面对上面的业务场景，还有什么好的实现方式吗？</p><p>答案是<strong>规则引擎</strong>。</p><h1 id="规则引擎概述"><a href="#规则引擎概述" class="headerlink" title="规则引擎概述"></a>规则引擎概述</h1><h2 id="什么是规则引擎"><a href="#什么是规则引擎" class="headerlink" title="什么是规则引擎"></a>什么是规则引擎</h2><p><strong>规则引擎</strong>，全称为<strong>业务规则管理系统</strong>，英文名为 BRMS（即 Business Rule Management System）。规则引擎的主要思想是将应用程序中的业务决策部分分离出来，并使用预定义的语义模块编写业务决策（业务规则），由用户或开发者在需要时进行配置、管理。</p><p>需要注意的是规则引擎并不是一个具体的技术框架，而是指的一类系统，即业务规则管理系统。目前市面上具体的规则引擎产品有：drools、VisualRules、iLog 等。</p><p>规则引擎实现了将业务决策从应用程序代码中分离出来，接收数据输入，解释业务规则，并根据业务规则做出业务决策。规则引擎其实就是一个输入输出平台。</p><p>上面的申请信用卡业务场景使用规则引擎后效果如下：</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/image-20230707134252233.png" alt="image-20230707134252233"></p><p>系统中引入规则引擎后，业务规则不再以程序代码的形式驻留在系统中，取而代之的是处理规则的规则引擎，业务规则存储在规则库中，完全独立于程序。业务人员可以像管理数据一样对业务规则进行管理，比如查询、添加、更新、统计、提交业务规则等。业务规则被加载到规则引擎中供应用系统调用。</p><h2 id="使用规则引擎的优势"><a href="#使用规则引擎的优势" class="headerlink" title="使用规则引擎的优势"></a>使用规则引擎的优势</h2><p>使用规则引擎的优势如下：</p><ol><li>业务规则与系统代码分离，实现业务规则的集中管理</li><li>在不重启服务的情况下可随时对业务规则进行扩展和维护</li><li>可以动态修改业务规则，从而快速响应需求变更</li><li>规则引擎是相对独立的，只关心业务规则，使得业务分析人员也可以参与编辑、维护系统的业务规则</li><li>减少了硬编码业务规则的成本和风险</li><li>使用规则引擎提供的规则编辑工具，使复杂的业务规则实现变得的简单</li></ol><h2 id="规则引擎应用场景"><a href="#规则引擎应用场景" class="headerlink" title="规则引擎应用场景"></a>规则引擎应用场景</h2><p>对于一些存在比较复杂的业务规则并且业务规则会频繁变动的系统比较适合使用规则引擎，如下：</p><ol><li>风险控制系统：风险贷款、风险评估</li><li>反欺诈项目：银行贷款、征信验证</li><li>决策平台系统：财务计算</li><li>促销平台系统：满减、打折、加价购</li></ol><h2 id="Drools-介绍"><a href="#Drools-介绍" class="headerlink" title="Drools 介绍"></a>Drools 介绍</h2><p>drools 是一款由 JBoss 组织提供的基于 Java 语言开发的开源规则引擎，可以将复杂且多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件或特定的存储介质中（例如存放在数据库中），使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效。</p><p><a href="https://drools.org/">drools 官网地址</a></p><p><a href="https://github.com/kiegroup/drools">drools 源码下载地址</a></p><p>在项目中使用 drools 时，即可以单独使用也可以整合 spring 使用。如果单独使用只需要导入如下 maven 坐标即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们使用 IDEA 开发 drools 应用，IDEA 中已经集成了 drools 插件。</p><p>drools API 开发步骤如下（有点类似原生 JDBC）：</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/image-20230707134645845.png" alt="image-20230707134645845"></p><h1 id="Drools-入门案例"><a href="#Drools-入门案例" class="headerlink" title="Drools 入门案例"></a>Drools 入门案例</h1><p>本小节通过一个 Drools 入门案例来初步了解 Drools 的使用方式、对 Drools 有一个整体概念。</p><h2 id="业务场景说明"><a href="#业务场景说明" class="headerlink" title="业务场景说明"></a>业务场景说明</h2><p>业务场景：消费者在图书商城购买图书，下单后需要在支付页面显示订单优惠后的价格。具体优惠规则如下：</p><table><thead><tr><th>规则编号</th><th>规则名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>规则一</td><td>所购图书总价在100元以下的没有优惠</td></tr><tr><td>2</td><td>规则二</td><td>所购图书总价在100到200元的优惠20元</td></tr><tr><td>3</td><td>规则三</td><td>所购图书总价在200到300元的优惠50元</td></tr><tr><td>4</td><td>规则四</td><td>所购图书总价在300元以上的优惠100元</td></tr></tbody></table><p>现在需要根据上面的规则计算优惠后的价格。</p><h2 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h2><ol><li><p>创建 maven 工程 <code>drools_quickstart</code> 并导入 drools 相关 maven 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--单元测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据 drools 要求创建 <code>resources/META-INF/kmodule.xml</code> 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">kmodule</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.drools.org/xsd/kmodule&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name：指定 kbase 的名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">        packages：指定规则文件的目录，需要根据实际情况填写，否则无法加载到规则文件</span></span><br><span class="line"><span class="comment">        default：指定当前 kbase 是否为默认</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kbase</span> <span class="attr">name</span>=<span class="string">&quot;myKbase1&quot;</span> <span class="attr">packages</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            name：指定 ksession 名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">            default：指定当前 ksession 是否为默认</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ksession</span> <span class="attr">name</span>=<span class="string">&quot;ksession-rule&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kbase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kmodule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：上面配置文件的名称和位置都是固定写法</p></li><li><p>创建实体类 <code>Order</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单原始价格，即优惠前价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double originalPrice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单真实价格，即优惠后价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double realPrice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;originalPrice=&quot;</span> + originalPrice +</span><br><span class="line">                <span class="string">&quot;, realPrice=&quot;</span> + realPrice +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getOriginalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOriginalPrice</span><span class="params">(Double originalPrice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.originalPrice = originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getRealPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> realPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRealPrice</span><span class="params">(Double realPrice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realPrice = realPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建规则文件 <code>resources/rules/bookDiscount.drl</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图书优惠规则</span></span><br><span class="line">package book.<span class="property">discount</span></span><br><span class="line"><span class="keyword">import</span> entity.<span class="property">Order</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：所购图书总价在100元以下的没有优惠</span></span><br><span class="line">rule <span class="string">&quot;book_discount_1&quot;</span></span><br><span class="line">    when</span><br><span class="line">        <span class="attr">$order</span>:<span class="title class_">Order</span>(originalPrice &lt; <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.<span class="title function_">setRealPrice</span>($order.<span class="title function_">getOriginalPrice</span>());</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;成功匹配到规则一：所购图书总价在100元以下的没有优惠&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则二：所购图书总价在100到200元的优惠20元</span></span><br><span class="line">rule <span class="string">&quot;book_discount_2&quot;</span></span><br><span class="line">    when</span><br><span class="line">        <span class="attr">$order</span>:<span class="title class_">Order</span>(originalPrice &lt; <span class="number">200</span> &amp;&amp; originalPrice &gt;= <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.<span class="title function_">setRealPrice</span>($order.<span class="title function_">getOriginalPrice</span>() - <span class="number">20</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;成功匹配到规则二：所购图书总价在100到200元的优惠20元&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则三：所购图书总价在200到300元的优惠50元</span></span><br><span class="line">rule <span class="string">&quot;book_discount_3&quot;</span></span><br><span class="line">    when</span><br><span class="line">        <span class="attr">$order</span>:<span class="title class_">Order</span>(originalPrice &lt;= <span class="number">300</span> &amp;&amp; originalPrice &gt;= <span class="number">200</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.<span class="title function_">setRealPrice</span>($order.<span class="title function_">getOriginalPrice</span>() - <span class="number">50</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;成功匹配到规则三：所购图书总价在200到300元的优惠50元&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则四：所购图书总价在300元以上的优惠100元</span></span><br><span class="line">rule <span class="string">&quot;book_discount_4&quot;</span></span><br><span class="line">    when</span><br><span class="line">        <span class="attr">$order</span>:<span class="title class_">Order</span>(originalPrice &gt;= <span class="number">300</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.<span class="title function_">setRealPrice</span>($order.<span class="title function_">getOriginalPrice</span>() - <span class="number">100</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;成功匹配到规则四：所购图书总价在300元以上的优惠100元&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>编写单元测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DroolsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">KieServices</span> <span class="variable">kieServices</span> <span class="operator">=</span> KieServices.Factory.get();</span><br><span class="line">        <span class="type">KieContainer</span> <span class="variable">kieClasspathContainer</span> <span class="operator">=</span> kieServices.getKieClasspathContainer();</span><br><span class="line">        <span class="comment">//会话对象，用于和规则引擎交互</span></span><br><span class="line">        <span class="type">KieSession</span> <span class="variable">kieSession</span> <span class="operator">=</span> kieClasspathContainer.newKieSession();</span><br><span class="line">        <span class="comment">//构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setOriginalPrice(<span class="number">210D</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配</span></span><br><span class="line">        kieSession.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//激活规则引擎，如果规则匹配成功则执行规则</span></span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        <span class="comment">//关闭会话</span></span><br><span class="line">        kieSession.dispose();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;优惠前原始价格：&quot;</span> + order.getOriginalPrice() +</span><br><span class="line">                <span class="string">&quot;，优惠后价格：&quot;</span> + order.getRealPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过上面的入门案例可以发现，使用 drools 规则引擎主要工作就是编写规则文件，在规则文件中定义跟业务相关的业务规则，例如本案例定义的就是图书优惠规则。规则定义好后就需要调用 drools 提供的<code>API</code>将数据提供给规则引擎进行规则模式匹配，规则引擎会执行匹配成功的规则并将计算的结果返回。</p><p>可能会有疑问，就是虽然没有在代码中编写规则的判断逻辑，但是还是在规则文件中编写了业务规则，这跟在代码中编写规则有什么本质的区别呢？</p><p>前面其实已经提到，使用规则引擎时业务规则可以做到动态管理。业务人员可以像管理数据一样对业务规则进行管理，比如查询、添加、更新、统计、提交业务规则等。这样就可以做到在不重启服务的情况下调整业务规则。（后面会说到通过编写 Excel 来制定规则并通过代码转为 drools 脚本，这样业务人员就可以只关注规则就可以，开发人员也不用再关心规则是什么）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="规则引擎构成"><a href="#规则引擎构成" class="headerlink" title="规则引擎构成"></a>规则引擎构成</h3><p>drools 规则引擎由以下三部分构成：</p><ul><li>Working Memory（工作内存）</li><li>Rule Base（规则库）</li><li>Inference Engine（推理引擎）</li></ul><p>其中 Inference Engine（推理引擎）又包括：</p><ul><li>Pattern Matcher（匹配器）</li><li>Agenda（议程）</li><li>Execution Engine（执行引擎）</li></ul><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/20230707105207.png" alt="20230707105207"></p><h3 id="相关概念说明"><a href="#相关概念说明" class="headerlink" title="相关概念说明"></a>相关概念说明</h3><p><strong>Working Memory</strong>：工作内存，drools 规则引擎会从 Working Memory 中获取数据并和规则文件中定义的规则进行模式匹配，所以开发的应用程序只需要将我们的数据插入到 Working Memory 中即可，例如本案例中调用 <code>kieSession.insert(order)</code> 就是将 <code>order</code> 对象插入到了工作内存中。</p><p><strong>Fact</strong>：事实，是指在 drools 规则应用当中，将一个普通的 <code>JavaBean</code> 插入到 Working Memory 后的对象就是 Fact 对象，例如本案例中的 <code>order</code> 对象就属于 Fact 对象。Fact 对象是我们的应用和规则引擎进行数据交互的桥梁或通道。</p><p><strong>Rule Base</strong>：规则库，我们在规则文件中定义的规则都会被加载到规则库中。</p><p><strong>Pattern Matcher</strong>：匹配器，将 Rule Base 中的所有规则与 Working Memory 中的 Fact 对象进行模式匹配，匹配成功的规则将被激活并放入 Agenda 中。</p><p><strong>Agenda</strong>：议程，用于存放通过匹配器进行模式匹配后被激活的规则。</p><p><strong>Execution Engine</strong>：执行引擎，执行 Agenda 中被激活的规则。</p><h3 id="规则引擎执行过程"><a href="#规则引擎执行过程" class="headerlink" title="规则引擎执行过程"></a>规则引擎执行过程</h3><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/image-20230707111732345.png" alt="image-20230707111732345"></p><h3 id="KIE-介绍"><a href="#KIE-介绍" class="headerlink" title="KIE 介绍"></a>KIE 介绍</h3><p>我们在操作 drools 时经常使用的 <code>API</code> 以及它们之间的关系如下图：</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/image-20230707112032674.png" alt="image-20230707112032674"></p><p>通过上面的核心 <code>API</code> 可以发现，大部分类名都是以 Kie 开头。Kie 全称为 Knowledge Is Everything，即“知识就是一切”的缩写，是 Jboss 一系列项目的总称。如下图所示，Kie 的主要模块有 OptaPlanner、Drools、UberFire、jBPM。</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/image-20230707112425751.png" alt="image-20230707112425751"></p><p>通过上图可以看到，Drools 是整个 KIE 项目中的一个组件，Drools 中还包括一个 <strong>Drools-WB</strong> 的模块，它是一个可视化的规则编辑器（后面会用到）。</p>]]></content>
      
      
      <categories>
          
          <category> 企业应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 规则引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ深度解析（上）</title>
      <link href="/2023/07/05/RocketMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/07/05/RocketMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ-介绍"><a href="#RocketMQ-介绍" class="headerlink" title="RocketMQ 介绍"></a>RocketMQ 介绍</h1><p>RocketMQ 作为一款纯 java、分布式、队列模型的开源消息中间件，支持事务消息、顺序消息、批量消息、延时消息、消息回溯等。<br>前身是 MetaQ，是阿里研发的一个队列模型的消息中间件，后开源给 apache 基金会成为了 apache 的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。</p><h2 id="RocketMQ-特点"><a href="#RocketMQ-特点" class="headerlink" title="RocketMQ 特点"></a>RocketMQ 特点</h2><ul><li>支持发布&#x2F;订阅和点对点消息模型</li><li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递：RocketMQ 默认是多线程处理消息，如果要保证严格按照顺序传递，则需要将多线程改为单线程</li><li>支持拉（pull）和推（push）两种消息模式：拉模式在旧版本支持，现在新版本在慢慢的不推荐拉模式</li><li>单一队列百万消息的堆积能力（RocketMQ 提供亿级消息的堆积能力，重点是堆积了亿级的消息后，依然保持写入低延迟），而且现在是推模式，只要消费端不是特别慢，RocketMQ 是不会有什么问题的</li><li>支持多种消息协议，如 JMS、MQTT 等</li><li>分布式高可用的部署架构，满足至少一次消息传递语义</li><li>提供 docker 镜像用于隔离测试和云集群部署</li><li>提供配置、指标和监控等功能丰富的 Dashboard</li></ul><h2 id="RocketMQ-优势"><a href="#RocketMQ-优势" class="headerlink" title="RocketMQ 优势"></a>RocketMQ 优势</h2><ul><li>支持事务型消息（消息发送和 DB 操作保持两方的最终一致性，RabbitMQ 和 Kafka 不支持），二阶段提交事务消息，如果只是一次也就是 half message 的话是不允许提交的</li><li>支持结合 RocketMQ 的多个系统之间数据最终一致性（多方事务，二方事务是前提）</li><li>支持 18 个级别的延迟消息（kafka 不支持），1s、3s、……2h</li><li>支持指定次数和时间间隔的失败消息重发（Kafka 不支持，RabbitMQ 需要手动确认）</li><li>支持 Broker 端 Tag 过滤，减少不必要的传输（RabbitMQ 和 Kafka 不支持）。给消息打标签，消费者通过标签区分业务，生产者不需要区分业务放不同的 broker</li><li>支持重复消费（RabbitMQ 不支持，Kafka 支持）</li></ul><h1 id="RockerMQ-基本概念"><a href="#RockerMQ-基本概念" class="headerlink" title="RockerMQ 基本概念"></a>RockerMQ 基本概念</h1><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2Frocket1.png" alt="image.png"><br>zk cap中cp 强一致性 </p><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p>NameServer 是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。<br>NameServer 是整个 RocketMQ 的“大脑”，它是 RocketMQ 的服务注册中心，所以 RocketMQ 需要先启动 NameServer 再启动 Rocket 中的 Broker</p><h3 id="NameServer-作用"><a href="#NameServer-作用" class="headerlink" title="NameServer 作用"></a>NameServer 作用</h3><p>名称服务器（NameServer）用来保存 Broker 相关元信息并给 Producer 和 Consumer 查找 Broker 信息。<br>NameServer 被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个集群。<br>每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息，所以从功能上看应该是和 ZooKeeper 差不多，据说 RocketMQ 的早期版本确实是使用的 ZooKeeper，后来改为了自己实现 NameServer。</p><h3 id="NameServer-和-zk-的区别"><a href="#NameServer-和-zk-的区别" class="headerlink" title="NameServer 和 zk 的区别"></a>NameServer 和 zk 的区别</h3><p>zk 主要保证了 cap 中的 cp，强一致性。<br>NameServer 和 ZooKeeper 的作用大致是相同的，从宏观上来看，NameServer 做的东西很少，就是保存一些运行数据，NameServer 之间不互连，这就需要 broker 端连接所有的 NameServer，运行数据的改动要发送到每一个 NameServer 来保证运行数据的一致性（这个一致性确实有点弱），这样就变成了 NameServer 很轻量级，但是 broker 端就要做更多的东西了。<br>而 ZooKeeper 呢，broker 只需要连接其中的一台机器，运行数据分发、一致性都交给了 ZooKeeper 来完成。</p><h3 id="高可用保障"><a href="#高可用保障" class="headerlink" title="高可用保障"></a>高可用保障</h3><p>Broker 在启动时向所有 NameServer 注册（主要是服务器地址等），生产者在发送消息之前先从 NameServer 获取 Broker 服务器地址列表（消费者一样），然后根据负载均衡算法从列表中选择一台服务器进行消息发送。<br>NameServer 与每台 Broker 服务保持长连接，并间隔10S检查 Broker 是否存活，如果检测到 Broker 宕机，则从路由注册表中将其移除，这样就可以实现 RocketMQ 的高可用。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>消息服务器（Broker）是消息存储中心，主要作用是接收来自 Producer 的消息并存储，Consumer 从这里取得消息，它还存储与消息相关的元数据，包括用户组、消费进度偏移量、队列信息等，从部署结构图中可以看出 Broker 有 Master 和 Slave 两种类型，Master 既可以写又可以读，Slave 不可以写只可以读。只有当 Master 挂了之后，Consumer 才会去 Slave 读消息。Producer 存储消息时同一个消息只会保存在一个 Broker 上，Broker 之间不会互相同步数据。</p><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>Broker 部署相对复杂，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 与 Slave 的对应关系通过指定相同的 Broker Name，不同的 Broker Id 来定义，BrokerId 为0表示 Master，非0表示 Slave，Master 也可以部署多个。<br>从物理结构上看 Broker 的集群部署方式有四种：单 Master、多 Master、多 Master 多 Slave（同步复制）、多 Master 多 Slave（异步复制）</p><h4 id="单-Master"><a href="#单-Master" class="headerlink" title="单 Master"></a>单 Master</h4><p>这种方式一旦 Broker 重启或宕机会导致整个服务不可用，这种方式风险较大，所以不建议线上环境使用。</p><h4 id="多-Master"><a href="#多-Master" class="headerlink" title="多 Master"></a>多 Master</h4><p>所有消息服务器都是 Master，没有 Slave，这种方式优点是配置简单，单个 Master 宕机或重启维护对应用无影响，缺点是单台机器宕机期间，该机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受影响。</p><h4 id="多-Master-多-Slave（异步复制）"><a href="#多-Master-多-Slave（异步复制）" class="headerlink" title="多 Master 多 Slave（异步复制）"></a>多 Master 多 Slave（异步复制）</h4><p>每个 Master 配置一个 Slave，所以有多对 Master-Slave，消息采用异步复制方式，主备之间有毫秒级消息延迟，这种方式优点是消息丢失的非常少，且消息实时性不会受影响，Master 宕机后消费者可以继续从 Slave 消费，中间的过程对用户应用程序透明，不需要人工干预，性能同多 Master 方式几乎一样，缺点是 Master 宕机时在磁盘损坏情况下会丢失极少量消息。</p><h4 id="多Master多Slave（同步复制）"><a href="#多Master多Slave（同步复制）" class="headerlink" title="多Master多Slave（同步复制）"></a>多Master多Slave（同步复制）</h4><p>每个Master配置一个Slave，所以有多对Master-Slave，消息采用同步复制方式，<strong>主备都写成功才返回成功</strong>，这种方式优点是数据与服务都没有单点问题，Master宕机时消息无延迟，服务与数据的可用性非常高，缺点是性能相对异步复制方式略低，发送消息的延迟会略高。<br>说明：复制是数据从master复制到Slave，刷盘是持久化</p><h3 id="高可用保障-1"><a href="#高可用保障-1" class="headerlink" title="高可用保障"></a>高可用保障</h3><p>每个Broker与Name Server集群中的所有节点建立长连接，定时(每隔30s)注册Topic信息到所有Name Server，Name Server定时(每隔10s)扫描所有存活broker的连接，如果Name Server超过2分钟没有收到心跳，则Name Server断开与Broker的连接</p><h2 id="生产者（Producer）"><a href="#生产者（Producer）" class="headerlink" title="生产者（Producer）"></a>生产者（Producer）</h2><p>也称为消息发布者，负责生产并发送消息至Topic<br>生产者向brokers发送由业务应用程序系统生成的消息，RocketMQ提供了发送：同步、异步和单向（one-way）的多种模式</p><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包，一般用于重要通知消息，例如重要通知邮件、短信。</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。通过监听回调，获取发送结果。</p><h3 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h3><p>单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。这点类似kafka的发送并忘记。</p><h3 id="生产者组"><a href="#生产者组" class="headerlink" title="生产者组"></a>生产者组</h3><p>生产者组（Producer Group）是一类Producer的集合，这类Producer通常发送一类消息并且发送逻辑一致，所以将这些Producer分组在一起，从部署结构上看生产者通过Producer Group的名字来标记自己是一个集群。</p><h3 id="高可用保障-2"><a href="#高可用保障-2" class="headerlink" title="高可用保障"></a>高可用保障</h3><p>Producer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳，Producer完全无状态，可集群部署。<br>Producer每隔30s（由ClientConfig的pollNameServerInterval）从Name Server获取所有topic队列的最新情况，这意味着如果Broker不可用，Producer最多30s能够感知，在此期间内发往Broker的所有消息都会失败。<br>Producer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s中扫描所有存活的连接，如果Broker在2分钟内没有收到心跳数据，则关闭与Producer的连接。</p><h2 id="消费者（Consumer）"><a href="#消费者（Consumer）" class="headerlink" title="消费者（Consumer）"></a>消费者（Consumer）</h2><p>也称为消息订阅者，负责从Topic接收并消费消息<br>消费者从brokers那里拉取信息并将其输入应用程序，在用户应用的角度，提供了两种类型的消费者：</p><ul><li>Pull：Pull型消费者主动地从brokers那里拉取信息，只要批量拉取到消息，用户应用程序就会启动消费过程</li><li>Push：Push型消费者封装消息的拉取、消费进度和维护内部的其他工作，将一个在消息到达时执行的回调接口留给终端用户来实现</li></ul><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>消费者组（Consumer Group）一类Consumer的集合名称，这类Consumer通常消费同一类消息并且消费逻辑一致，所以将这些Consumer分组在一起，消费者组与生产者组类似，都是将相同角色的分组在一起并命名，分组是个很精妙的概念设计，RocketMQ正是通过这种分组机制，实现了天然的消息负载均衡。<br>消费消息时通过Consumer Group实现了将消息分发到多个消费者服务器实例，比如某个Topic有9条消息，其中一个Consumer Group有3个实例（3个进程或3台机器），那么每个实例将均摊3条消息，这也意味着我们可以很方便的通过加机器来实现水平扩展。</p><h3 id="高可用保障-3"><a href="#高可用保障-3" class="headerlink" title="高可用保障"></a>高可用保障</h3><p>Consumer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳，Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。<br>Consumer每隔30s从Name server获取topic的最新队列情况，这意味着Broker不可用时，Consumer最多需要30s才能感知。<br>Consumer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s扫描所有存活的连接，若某个连接2分钟内没有发送心跳数据，则关闭连接；并向该Consumer Group的所有Consumer发出通知，Group内的Consumer重新分配队列，然后继续消费。<br>当Consumer得到master宕机通知后，转向slave消费，slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失，但是一旦master恢复，未同步过去的消息会被最终消费掉。</p><h2 id="运转流程"><a href="#运转流程" class="headerlink" title="运转流程"></a>运转流程</h2><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2Frocket2.png" alt="image.png"></p><ol><li>Name Server先启动</li><li>Broker启动时向NameServer注册</li><li>生产者在发送某个主题的消息之前先从NameServer获取Broker服务器地址列表（有可能是集群），然后根据负载均衡算法从列表中选择一台Broker进行消息发送</li><li>NameServer与每台Broker服务器保持长连接，并间隔10S检测Broker是否存活，如果检测到Broker宕机（使用心跳机制，如果检测超过120S），则从路由注册表中将其移除</li><li>消费者在订阅某个主题的消息之前从NamerServer获取Broker服务器地址列表（有可能是集群），但是消费者选择从Broker中订阅消息，订阅规则由Broker配置决定</li></ol><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息（Message）就是要传输的信息，一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址，一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务key并在Broker上查找此消息以便在开发期间查找问题。</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>主题（Topic）可以看做消息的规类，它是消息的第一级类型。<br>比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个Topic，Topic与生产者和消费者的关系非常松散，一个Topic可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息，一个Topic也可以被0个、1个、多个消费者订阅<br>注意：一个topic默认四个消息队列</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签（Tag）可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。<br>使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的Tag来标识，比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有Tag，标签有助于保持您的代码干净和连贯，并且还可以为RocketMQ提供的查询系统提供帮助。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列（Message Queue），主题被划分为一个或多个子主题，即消息队列。<br>一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。</p><h3 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h3><p>消息消费模式有两种：集群消费（Clustering）和广播消费（Broadcasting）<br>默认情况下就是集群消费，该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。<br>而广播消费消息会发给消费者组中的每一个消费者进行消费。</p><h3 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h3><p>消息顺序（Message Order）有两种：顺序消费（Orderly）和并行消费（Concurrently）<br>顺序消费表示消息消费的顺序同生产者为每个消息队列发送的顺序一致，所以如果正在处理全局顺序是强制性的场景，需要确保使用的主题只有一个消息队列，并行消费不再保证消息顺序，消费的最大并行数量受每个消费者客户端指定的线程池限制。</p><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>RocketMQ的设计基于主题的发布与订阅模式，其核心功能包括消息发送、消息存储(Broker)、消息消费，整体设计追求简单与性能第一，主要体现在以下三个方面</p><h2 id="NameServer设计及其简单"><a href="#NameServer设计及其简单" class="headerlink" title="NameServer设计及其简单"></a>NameServer设计及其简单</h2><p>RocketMQ摒弃了业界常用的zookeeper作为注册中心，而是使用自研的NameServer来实现元数据的管理，因为Topic路由信息无须在集群间保持强一致性，追求最终一致性，并且能容忍分钟级的不一致，所以RocketMQ的NameServer集群间互不通信，极大降低了设计的复杂度，降低了对网络的要求，提升性能。</p><h2 id="高效的IO存储机制"><a href="#高效的IO存储机制" class="headerlink" title="高效的IO存储机制"></a>高效的IO存储机制</h2><p>RocketMQ追求消息发送的高吞吐量，RocketMQ消息存储文件设计成文件组的概念，组内单个文件大小固定，方便引入内存映射机制。<br>所有主题的消息存储基于顺序写，提升写性能，同时为了兼顾消息消费与消息查找，引入了消息消费队列文件与索引文件。</p><h2 id="容忍存在的设计缺陷"><a href="#容忍存在的设计缺陷" class="headerlink" title="容忍存在的设计缺陷"></a>容忍存在的设计缺陷</h2><p>适当将某些工作下放给RocketMQ使用者，消息中间件的实现者经常会遇到一个难题：<br>如何保证消息一定能被消息消费者消费，并且保证只消费一次，RocketMQ的设计者给出的解决办法是不解决这个难题，而是退而求其次，只保证消息被消费者消费，但设计上允许消息被重复消费，这样极大地简化了消息中间件的内核，使得实现消息发送高可用变得非常简单与高效，消息重复问题由消费者在消息消费时实现幂等。</p><h1 id="RocketMQ架构"><a href="#RocketMQ架构" class="headerlink" title="RocketMQ架构"></a>RocketMQ架构</h1><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2Frocket3.png" alt="image.png"></p><h2 id="NameServer集群"><a href="#NameServer集群" class="headerlink" title="NameServer集群"></a>NameServer集群</h2><p>提供轻量级的服务发现及路由，每个NameServer记录完整的路由信息，提供相应的读写服务，支持快速存储扩展，有些其它开源中间件使用ZooKeeper实现服务发现及路由功能，如Apache Kafka。<br>NameServer是一个功能齐全的服务器，主要包含两个功能：</p><ol><li>Broker管理，接收来自Broker集群的注册请求，提供心跳机制检测Broker是否存活</li><li>路由管理，每个NameServer持有全部有关Broker集群和客户端请求队列的路由信息</li></ol><h2 id="Broker集群"><a href="#Broker集群" class="headerlink" title="Broker集群"></a>Broker集群</h2><p>通过提供轻量级的Topic和Queue机制处理消息存储。<br>同时支持推（Push）和拉（Pull）两种模型，包含容错机制。提供强大的峰值填充和以原始时间顺序累积数千亿条消息的能力，此外还提供灾难恢复，丰富的指标统计数据和警报机制，这些都是传统的消息系统缺乏的。<br>Broker有几个重要的子模块：</p><ol><li>远程处理模块，Broker入口，处理来自客户端的请求</li><li>客户端管理，管理客户端（包括消息生产者和消费者），维护消费者的主题订阅</li><li>存储服务，提供在物理硬盘上存储和查询消息的简单API</li><li>HA服务，提供主从Broker间数据同步</li><li>索引服务，通过指定键为消息建立索引并提供快速消息查询</li></ol><h2 id="Producer集群"><a href="#Producer集群" class="headerlink" title="Producer集群"></a>Producer集群</h2><p>消息生产者支持分布式部署，分布式生产者通过多种负载均衡模式向Broker集群发送消息。</p><h2 id="Consumer集群"><a href="#Consumer集群" class="headerlink" title="Consumer集群"></a>Consumer集群</h2><p>消息消费者也支持Push和Pull模型的分布式部署，还支持集群消费和消息广播，提供了实时的消息订阅机制，可以满足大多数消费者的需求。<br>有关架构图中集群间交互方式的说明：</p><ol><li>Broker Master和Broker Slave是主从结构，会执行数据同步Data Sync</li><li>每个Broker与NameServer集群中所有节点建立长连接，定时注册Topic信息到所有NameServer</li><li>Producer与NameServer集群中的其中一个节点（随机）建立长连接，定期从NameServer获取Topic路由信息，并与提供Topic服务的BrokerMaster建立长连接，定时向Broker发送心跳</li><li>Producer只能将消息发送到Broker Master，但是Consumer同时和提供Topic服务的Master和Slave建立长连接，既可以从Master订阅消息，也可以从Slave订阅消息</li></ol><h1 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h1><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p>RocketMQ与大部分消息中间件一样，采用发布订阅模式，基本的参与组件主要包括：消息发送者、消息服务器（消息存储）、消息消费、路由发现。</p><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>顺序消息（FIFO：First Input First Output）是一种严格按照顺序进行发布和消费的消息类型，要求消息的发布和消息消费都按照顺序进行，RocketMQ可以严格保证消息有序。<br>RocketMQ可以严格的保证消息有序，但这个顺序不是全局顺序，只是分区（queue）顺序，要全局顺序只能一个分区，但是同一条queue里面，RocketMQ的确是能保证FIFO的。</p><h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>消息过滤是指在消息消费时，消息消费者可以对同一主题下的消息按照规则只消费自己感兴趣的消息RocketMQ消息过滤支持在服务端与消费端的消息过滤机制。</p><ol><li>消息在Broker端过滤，Broker只将消息消费者感兴趣的消息发送给消息消费者</li><li>消息在消息消费端过滤，消息过滤方式完全由消息消费者自定义，但缺点是有很多无用的消息会从Broker传输到消费端</li></ol><h3 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h3><p>消息中间件的一个核心实现是消息的存储，对消息存储一般有如下两个维度的考量<br>消息堆积能力和消息存储性能，RocketMQ追求消息存储的高性能，引入内存映射机制，所有主题的消息顺序存储在同一个文件中，同时为了避免消息无限在消息存储服务器中累积，引入了消息文件过期机制与文件存储空间报警机制。</p><h2 id="消息高可用性"><a href="#消息高可用性" class="headerlink" title="消息高可用性"></a>消息高可用性</h2><p>通常影响消息可靠性的有以下几种情况</p><ol><li>Broker正常关机</li><li>Broker异常宕机</li><li>操作系统宕机</li><li>机器断电，但是能立即恢复供电情况</li><li>机器无法开机（可能是CPU、主板、内存等关键设备损坏）</li><li>磁盘设备损坏</li></ol><p>针对上述情况，情况1至4的RocketMQ在同步刷盘机制下可以确保不丢失消息，在异步刷盘模式下，会丢失少量消息。情况5至6属于单点故障，一旦发生，该节点上的消息全部丢失，如果开启了异步复制机制，RoketMQ能保证只丢失少量消息，而使用同步复制机制可以满足消息可靠性要求极高的场合。</p><h3 id="消息到消费低延迟"><a href="#消息到消费低延迟" class="headerlink" title="消息到消费低延迟"></a>消息到消费低延迟</h3><p>RocketMQ在消息不发生消息堆积时，以长轮询模式实现准实时的消息推送模式。</p><h3 id="确保消息必须被消费一次"><a href="#确保消息必须被消费一次" class="headerlink" title="确保消息必须被消费一次"></a>确保消息必须被消费一次</h3><p>RocketMQ通过消息消费确认机制（ACK）来确保消息至少被消费一次，但由于ACK消息有可能丢失等其他原因，RocketMQ无法做到消息只被消费一次，有重复消费的可能。</p><h3 id="回溯消息"><a href="#回溯消息" class="headerlink" title="回溯消息"></a>回溯消息</h3><p>回溯消息是指消息消费端已经消费成功的消息，由于业务要求需要重新消费消息，RocketMQ支持按时间回溯消息，时间维度可精确到毫秒，可以向前或向后回溯。</p><h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><p>消息中间件的主要功能是异步解耦，必须具备应对前端的数据洪峰，提高后端系统的可用性，必然要求消息中间件具备一定的消息堆积能力，RocketMQ消息存储使用磁盘文件（内存映射机制），并且在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用，RocketMQ消息存储文件并不是永久存储在消息服务器端，而是提供了过期机制，默认保留3天。</p><h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p>延时消息是指消息发送到Broker后，不能被消息消费端立即消费，要到特定的时间点或者等待特定的时间后才能被消费。<br>如果要支持任意精度的定时消息消费，必须在消息服务端对消息进行排序，势必带来很大的性能损耗，故RocketMQ不支持任意进度的定时消息，而只支持特定延迟级别。（一个说法是任意精度的定时消息会带来性能损耗，但是阿里云版本的RocketMQ却提供这样的功能，充值收费优先策略？）<br>注意：和RabbitMQ一样，如果第一个消息是延时10S，第二个延迟1S，得等第一个先消费后第二个才会消费。但是RocketMQ是多线程，如果不再同一个Queue中的话，则不影响。</p><h3 id="消息重试机制"><a href="#消息重试机制" class="headerlink" title="消息重试机制"></a>消息重试机制</h3><p>消息重试是指消息在消费时，如果发送异常，消息中间件需要支持消息重新投递，RocketMQ支持消息重试机制。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 源码学习 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ深度解析（下）</title>
      <link href="/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h1><h2 id="什么是延时任务"><a href="#什么是延时任务" class="headerlink" title="什么是延时任务"></a>什么是延时任务</h2><p>延时任务不是定时任务，需有前置条件。比如生成订单30min未支付，则自动取消。前置条件是下单。定时任务则不需要有前置条件，到点或按频率执行就行。</p><h2 id="和定时任务的区别"><a href="#和定时任务的区别" class="headerlink" title="和定时任务的区别"></a>和定时任务的区别</h2><ol><li>定时任务有明确的触发时间，延时任务没有</li><li>定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期</li><li>定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务</li></ol><h2 id="延时队列使用场景"><a href="#延时队列使用场景" class="headerlink" title="延时队列使用场景"></a>延时队列使用场景</h2><ul><li>订单在十分钟之内未支付则自动取消</li><li>账单在一周内未支付，则自动结算</li><li>用户注册成功后，如果没有修改初始密码进行提醒</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li><li>等</li></ul><p>规范建议：数据库中如果时间字段经常排序、查询操作建议存 long 值，效率更快。原因是2023-09-01这种在查询和排序时，数据库也是转为 long 值后再进行操作。</p><h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><h3 id="数据库轮询（定时思想）"><a href="#数据库轮询（定时思想）" class="headerlink" title="数据库轮询（定时思想）"></a>数据库轮询（定时思想）</h3><p>该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行 update 或 delete 等操作。<br>优点：简单易行，支持集群操作，可快速上线。适用于项目前期数据量小的场景<br>缺点：对服务器内存消耗大；存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟；假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大</p><h3 id="JDK-的延迟队列"><a href="#JDK-的延迟队列" class="headerlink" title="JDK 的延迟队列"></a>JDK 的延迟队列</h3><p>该方案是利用 JDK 自带的 DelayQueue 来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入 DelayQueue 中的对象，是必须实现 Delayed 接口的。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-1.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK的延迟队列示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Tengbin Li </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/6/2 16:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkDelayDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        DelayQueue&lt;MyDelay&gt; delayQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>();</span><br><span class="line">        delayQueue.add(<span class="keyword">new</span> <span class="title class_">MyDelay</span>(<span class="string">&quot;A&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        delayQueue.add(<span class="keyword">new</span> <span class="title class_">MyDelay</span>(<span class="string">&quot;B&quot;</span>, <span class="number">11</span>, TimeUnit.SECONDS));</span><br><span class="line">        delayQueue.add(<span class="keyword">new</span> <span class="title class_">MyDelay</span>(<span class="string">&quot;C&quot;</span>, <span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//取延迟任务，使用take的好处：如果没有延迟任务会进行阻塞，防止while循环导致CPU压力过大</span></span><br><span class="line">            <span class="type">MyDelay</span> <span class="variable">take</span> <span class="operator">=</span> delayQueue.take();</span><br><span class="line">            take.excute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义延迟任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyDelay</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 延迟时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name      任务名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> startTime 延迟时间</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit      时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MyDelay(String name, <span class="type">long</span> startTime, TimeUnit unit) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//延迟时间转毫秒值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">convert</span> <span class="operator">=</span> TimeUnit.MILLISECONDS.convert(startTime, unit);</span><br><span class="line">            <span class="built_in">this</span>.startTime = currentTime + convert;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法作用是告诉jdk是否执行任务，0表示执行，非0表示多长时间后执行</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (startTime &lt;= currentTimeMillis) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//休息时间差值，需将毫秒转成用户指定的单位类型</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">convert</span> <span class="operator">=</span> unit.convert(startTime - currentTimeMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">return</span> convert;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 作用是：任务1 10s后执行，任务2 5s后执行。排序 将5s放在10s前</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">            <span class="comment">//前一个任务</span></span><br><span class="line">            <span class="type">MyDelay</span> <span class="variable">prx</span> <span class="operator">=</span> (MyDelay) o;</span><br><span class="line">            <span class="type">MyDelay</span> <span class="variable">next</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (prx.startTime &lt; next.startTime) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prx.startTime &gt; next.startTime) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//执行延迟</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;执行延迟任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点：效率高，任务触发时间延迟低。<br>缺点：服务器重启后，数据全部消失，怕宕机。集群扩展相当麻烦。内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常。代码复杂度较高。</p><h3 id="netty-时间轮算法"><a href="#netty-时间轮算法" class="headerlink" title="netty 时间轮算法"></a>netty 时间轮算法</h3><blockquote><p>时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick</p></blockquote><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-2.png" alt="image.png"><br>这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的 tick 数），tickDuration（一个 tick 的持续时间）以及 timeUnit（时间单位），例如当 ticksPerWheel&#x3D;60，tickDuration&#x3D;1，timeUnit&#x3D;秒，这就和现实中的始终的秒针走动完全类似了。</p><p>如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈，位置是在2圈之后的5上面（20 % 8 + 1）。</p><p>优点：效率高，任务触发时间延迟时间比 delayQueue 低，代码复杂度比 delayQueue 低。<br>缺点：服务器重启后，数据全部消失，怕宕机。集群扩展相当麻烦。因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常。</p><h3 id="使用消息队列"><a href="#使用消息队列" class="headerlink" title="使用消息队列"></a>使用消息队列</h3><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-3.png" alt="image.png"><br>我们可以采用 RabbitMQ 的延时队列，RabbitMQ 具有以下两个特性，可以实现延迟队列</p><ul><li>RabbitMQ 可以针对 Queue 和 Message 设置 x-message-ttl，来控制消息的生存时间，如果超时，则消息变为 dead letter。</li><li>RabbitMQ 的 Queue 可以配置 x-dead-letter-exchange 和 x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了 dead letter，则按照这两个参数重新路由。</li></ul><p>优点：高效，可以利用 rabbitmq 的分布式特性轻易的进行横向扩展，消息支持持久化增加了可靠性。<br>缺点：本身的易用度要依赖于 RabbitMQ 的运维，因为要引用 RabbitMq，所以复杂度和成本变高。</p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>RabbitMQ 中没有对消息延迟进行实现，但是我们可以通过 TTL 以及死信路由来实现消息延迟。<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-4.png" alt="image.png"><br>TTL 消息过期时间<br>TTL 是 RabbitMq 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果再 TTL 设置的时间内没有被消费，则会称为“死信”，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">taxiOverQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">30000</span>);</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(TAXI_OVER_QUEUE).withArguments(args).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理解<br>一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列。</p><p><strong>死信队列使用场景</strong></p><ul><li>消费者对消息使用了 basicReject 或者 basicNack 回复，并且 requeue 参数设置为 false ，即不再将该消息重新在消费者间进行投递</li><li>消息在队列中超时，RabbitMQ 可以在单个消息或者队列中设置 TTL 属性</li><li>队列中的消息已经超过其设置的最大消息个数</li></ul><p>死信交换器不是默认的设置，这里是被投递消息被拒绝后的一个可选行为，是在创建队列的时进行声明的，往往用在对问题消息的诊断上。<br>死信交换器仍然只是一个普通的交换器，创建时并没有特别要求和操作，在创建队列的时候，声明该交换器将用作保存被拒绝的消息即可，相关的参数是 x-dead-letter-exchange。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-5.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列示例服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProducerDelay</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">route_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_route&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> currentTime + <span class="string">&quot;--hello rabbitMQ ,i am &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(exchange_name, route_key, <span class="literal">false</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;rabbitMQ send message key:【&quot;</span> + route_key + <span class="string">&quot;】,message【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于给死信队列投递消息的正常队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDelay</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; dlxMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置消息在延时队列等待时间 5s</span></span><br><span class="line">        dlxMap.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        dlxMap.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>);</span><br><span class="line">        <span class="comment">//死信路由键，会替换消息原来的路由键</span></span><br><span class="line">        dlxMap.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dead_key&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列，注意dlxMap</span></span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, dlxMap);</span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消费者在指定的对队列上消费，这里第三个参数为null，则不会消费消息等着超时放到死信队列上</span></span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列消费者（就是一个普通的消费者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDlx</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;dlx_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_dlx_queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;dead_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="comment">//声明消费者</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">receiveTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(receiveTime + <span class="string">&quot;--rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>单独指定每一条的消息的延时时间</strong><br>有个特殊情况，假如第一条消息过期时间指定10s，第二条指定1s，则会等第一条超时消费完后才会消费第二条，所以第二条的延迟时间也是10s。但要是第一条1s，第二条10s，则到了1s后会消费第一条，10s后会第二条。<br>有点特殊，个人不太建议使用这种。这种需要在发消息时就根据业务类型区分了不同的延时时间，耦合度高。建议还是按照上面的根据业务指定不同的消费队列，在队列中根据业务设置统一的延时时间。<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-6.png" alt="image.png"><br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-7.png" alt="image.png"><br>注意：如果消息过期时间和队列过期时间同时存在，谁的过期时间短，则以谁为准。（个人建议直接不要给消息单独设置过期时间）</p><h1 id="RabbitMQ-消息可靠性保障"><a href="#RabbitMQ-消息可靠性保障" class="headerlink" title="RabbitMQ 消息可靠性保障"></a>RabbitMQ 消息可靠性保障</h1><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-8.png" alt="image.png"><br>从上面的图可以看到，消息的投递有三个对象参与：</p><ul><li>生产者</li><li>broker</li><li>消费者</li></ul><h2 id="生产者保证"><a href="#生产者保证" class="headerlink" title="生产者保证"></a>生产者保证</h2><p>生产者发送消息到 broker 时，要保证消息的可靠性，主要的方案有以下2种：</p><ul><li>失败通知</li><li>发送方确认</li></ul><h3 id="失败通知"><a href="#失败通知" class="headerlink" title="失败通知"></a>失败通知</h3><p>如果出现消息无法投递到队列会出现失败通知。<br>mandatory&#x3D;true 消息发送时设置；内部类 ReturnListener 失败通知逻辑代码<br>注意：失败通知是能路由到队列则不发，不能路由到队列则发送。但是能路由到队列不代表消息能正常被消费，所以还有一个环节：发送方确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.sendconfirm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProducerConfirm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_confirm_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">route_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_confirm_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加失败通知监听，如果出现消息无法投递到队列会出现失败通知</span></span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> <span class="title class_">ReturnListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturn</span><span class="params">(<span class="type">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;失败通知--rabbitMQ sendConfirm replyCode:【&quot;</span> + replyCode + <span class="string">&quot;】,replyText:【&quot;</span> + replyText + <span class="string">&quot;】,exchange:【&quot;</span> + exchange + <span class="string">&quot;】,routingKey:【&quot;</span> + routingKey + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//交换器和队列绑定放到消费者进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello rabbitMQ ,i am &quot;</span> + i;</span><br><span class="line">            <span class="comment">//消息进行发送</span></span><br><span class="line">            <span class="comment">//mandatory=true，就是第三个参数</span></span><br><span class="line">            channel.basicPublish(exchange_name, route_key, <span class="literal">true</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;rabbitMQ send message key:【&quot;</span> + route_key + <span class="string">&quot;】,message【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            <span class="comment">//这里睡眠是为了保证服务端有时间可以收到失败通知</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送方确认"><a href="#发送方确认" class="headerlink" title="发送方确认"></a>发送方确认</h3><p>可路由：消息到达队列，并且队列保存消息成功（RabbitMQ 内部的逻辑，很难出现失败的情况）<br>不可路由：是否到达交换器，如果到达了交换器返回成功，没到达则失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//添加消息发送确认</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送方确认--消息发送成功，deliveryTag:&quot;</span> + deliveryTag + <span class="string">&quot;,multiple:&quot;</span> + multiple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送方确认--消息发送失败，deliveryTag:&quot;</span> + deliveryTag + <span class="string">&quot;,multiple:&quot;</span> + multiple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总结：<br>失败通知有，不管发送方确认是成功还是失败，结果都是失败。<br>失败通知没有，发送方确认是成功则成功，反之失败。</p><h2 id="broker-保证"><a href="#broker-保证" class="headerlink" title="broker 保证"></a>broker 保证</h2><h3 id="交换器持久化"><a href="#交换器持久化" class="headerlink" title="交换器持久化"></a>交换器持久化</h3><p>交换器持久化后，即便 RabbitMq 宕机重启后仍存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在信道中设置交换器 服务端</span></span><br><span class="line">channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器 消费端</span></span><br><span class="line">channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>队列持久化，即便 RabbitMq 宕机重启后仍存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明队列 第二个参数true</span></span><br><span class="line">channel.queueDeclare(queue_name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>发送消息时设置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = new AMQP.</span><br><span class="line">        BasicProperties.</span><br><span class="line">        Builder().</span><br><span class="line">//2表示持久化，1非持久化</span><br><span class="line">        deliveryMode(2).</span><br><span class="line">        build();</span><br><span class="line">//消息进行发送 第四个参数</span><br><span class="line">channel.basicPublish(exchange_name, route_key, true, properties, message.getBytes(&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure><p>注意消息持久化的前提时交换器和队列进行了持久化</p><h2 id="消费方保证"><a href="#消费方保证" class="headerlink" title="消费方保证"></a>消费方保证</h2><p>消费者接收到消息，但是还未处理或者还未处理完，此时消费者进程挂掉了，比如重启或者异常断电等，此时 mq 认为消费者已经完成消息消费，就会从队列中删除消息，从而导致消息丢失。<br>那该如何避免这种情况呢？这就要用到 RabbitMQ 提供的 ack 机制，RabbitMQ 默认是自动 ack 的，此时需要将其修改为手动 ack，也即自己的程序确定消息已经处理完成后，手动提交 ack，此时如果再遇到消息未处理进程就挂掉的情况，由于没有提交 ack，RabbitMQ 就不会删除这条消息，而是会把这条消息发送给其他消费者处理，但是消息是不会丢的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Consumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">        String message = new String(body, &quot;utf-8&quot;);</span><br><span class="line">        System.out.println(&quot;rabbitMQ receive message key:【&quot; + envelope.getRoutingKey() + &quot;】;message:【&quot; + message + &quot;】&quot;);</span><br><span class="line">int i = (int) (Math.random() * 10);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">//模拟出现问题</span><br><span class="line">        if (i % 2 != 0) &#123;</span><br><span class="line">            //失败时。参数1哪条消息、参数2是否批量nack、参数3是否重回队列</span><br><span class="line">            channel.basicNack(envelope.getDeliveryTag(), false, true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //成功时。参数1哪条消息、参数2是否批量ack</span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般业务上假如消息进行了5次nack后，可将消息不再重回队列，放入死信或数据库，进行告警。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 源码学习 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ深度解析（上）</title>
      <link href="/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="消息中间件（MQ）"><a href="#消息中间件（MQ）" class="headerlink" title="消息中间件（MQ）"></a>消息中间件（MQ）</h1><h2 id="消息队列回顾"><a href="#消息队列回顾" class="headerlink" title="消息队列回顾"></a>消息队列回顾</h2><blockquote><p>消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实<br>现高性能，高可用，可伸缩和最终一致性架构</p></blockquote><p>目前使用较多的消息队列有 ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ，消<br>息中间件到底该如何使用，何时使用这是一个问题，胡乱地使用消息中间件增加了系统的复杂度，如果<br>用不好消息中间件还不如不用。<br>消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式<br>系统的集成，通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信，对于消息<br>中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）。</p><h2 id="消息队列特点"><a href="#消息队列特点" class="headerlink" title="消息队列特点"></a>消息队列特点</h2><ol><li>先进先出：先进先出是队列的一个特性，数据是只有一条数据在使用中。</li><li>订阅：一般是 MQ 的广播模式，类似于 Java 的观察者模式，发布订阅是一种高效的处理方式，如果不发生阻塞，基本可以当作是同步操作。</li><li>持久化：MQ 能像数据库一样存储核心的数据。</li><li>分布式：在现在大流量、大数据的使用场景下，只支持单体应用的服务器软件基本是无法使用的，支持分布式的部署，才能被广泛使用，而且，MQ的定位就是一个高性能的中间件。</li></ol><h2 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a>为什么使用消息队列？</h2><p>解耦、异步、削峰</p><ol><li>解耦：举例快递业务。传统做法需要依次执行快递投柜，扣减费用，通知用户，通知快递公司，如果其中某一步异常（例如用户手机未开机或者快递公司接口故障），将会延迟甚至中断整个投柜流程，严重影响用户体验。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ1.png" alt="image.png">如果接口层收到投柜数据后，写入消息到 MQ，后续三个子系统各自消费处理，将可以完美解决该问题，并且子系统故障不影响上游系统！此为解耦！</li><li>异步：比如快递投柜后，用户马上就结束了，不会等待到发送短信或者通知快递公司结束的，直接将消息投递到 MQ，然后就直接结束，具体到扣减系统费以及后续的通知，都是异步操作的，不需要用户关心的，这就是将用户的同步操作转换为异步操作。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ2.png" alt="image.png">如果全部同步操作需要15s，而发送到 MQ 后交给系统异步处理用户只需要1s就可以完成操作。</li><li>流量削峰：就像用户投递快递，高峰到40W每秒，但是我们的后续处理业务每秒只能20W，还剩下20W在 MQ 进行堆积，这就是MQ很重要的流量削峰的能力，将用户的洪峰流量，让后台慢慢来处理，MQ 承担一个缓冲的作用。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ3.png" alt="image.png">就像这个波形图一样，如果用户请求的并发量的最高峰时40W，系统的承载能力只能达到30W，就可以使用MQ进行削峰，将系统最高40W的并发削峰为最高只有20万，就是时间换空间的做法。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ4.png" alt="image.png"></li></ol><h2 id="消息队列有什么缺点？"><a href="#消息队列有什么缺点？" class="headerlink" title="消息队列有什么缺点？"></a>消息队列有什么缺点？</h2><ol><li>系统可用性降低：我们投递快递，如果 MQ 出现问题，那么我们整个系统调用链路就会断开，前后端将无法通讯。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ5.png" alt="image.png"></li><li>系统复杂性提高：在使用消息队列的过程中，难免会出现生产者、MQ、消费者宕机不可用的情况，那么随之带来的问题就是消息重复、消息乱序、消息堆积等等问题都需要我们来控制。</li><li>一致性问题：如下图所示，系统需要保证快递投递，扣减系统费，通知等之间的数据一致性，如果系统短信通知，快递通知执行成功，扣减系统费执行失败时，就会出现数据不一致问题。应对方案，比如重试等方案。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ6.png" alt="image.png"></li></ol><h2 id="消息队列通讯模式"><a href="#消息队列通讯模式" class="headerlink" title="消息队列通讯模式"></a>消息队列通讯模式</h2><ol><li>点对点通讯：支持一对一，一对多，多对一，多对多。</li><li>发布&#x2F;订阅：</li><li>群集：为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster（群集）的解决方案。群集类似于一个域（Domain），群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集（Cluster）通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li></ol><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>RabbitMQ是流行的开源消息队列系统，用 erlang 语言开发，RabbitMQ 是 AMQP（高级消息队列协议）的标准实现。</p></blockquote><p>特性：</p><ul><li>erlang 语言开发，性能极其好，延时很低</li><li>吞吐量到万级，MQ功能比较完备</li><li>开源提供的管理界面非常棒，用起来很好用</li><li>社区相对比较活跃</li></ul><h1 id="怎样选择MQ？"><a href="#怎样选择MQ？" class="headerlink" title="怎样选择MQ？"></a>怎样选择MQ？</h1><p>横向对比<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ7.png" alt="image.png"></p><p>个人建议</p><ul><li>中小型公司，技术一般，可以考虑用 RabbitMQ。</li><li>大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>实时计算、日志采集：使用 kafka。</li></ul><p>如何选型</p><ul><li>RabbitMQ：erlang 开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降，每秒钟可以处理几万到十几万条消息。</li><li>RocketMQ：java 开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒钟大概能处理几十万条消息。</li><li>Kafka：Scala 开发，面向日志功能丰富，性能最高，当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高，所以，Kafka 不太适合在线业务场景。</li></ul><h1 id="RabbitMQ-基本使用"><a href="#RabbitMQ-基本使用" class="headerlink" title="RabbitMQ 基本使用"></a>RabbitMQ 基本使用</h1><p>RabbitMQ 与 AMQP 遵循相同的模型架构，其架构示例图如下<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ8.png" alt="image.png"><br><strong>Publisher</strong>：消费生产者，就是投递消息的程序，负责生产消息并将其投递到指定的交换器上。<br><strong>Message</strong>：消息，消息由消息头和消息体组成，消息头用于存储与消息相关的元数据：如目标交换器的名字（exchange_name）路由键（RountingKey）和其他可选配置（properties）信息。消息体为实际需要传递的数据。<br><strong>RountingKey</strong>：生产者将消息发给交换器的时候，一般会指定一个 RountingKey，用来指定这个消息的路由规则，当 RountingKey 与 BindingKey 基于交换器类型的规则相匹配时，消息将被路由到对应的队列中。<br>Exchange：交换器，负责接收来自生产者的消息，并将消息路由到一个或者多个队列中，如果路由不到，则返回给生产者或者直接丢弃，这取决于交换器的 mandatory 属性：true 返回给生产者，false 直接丢弃。<br>BindingKey：绑定 Key，交换器与队列通过 BindingKey 建立绑定关系。<br>Queue：消息队列载体，每个消息都会被投入到一个或者多个队列。用于存储路由过来的消息，多个消费者可以订阅同一个消息队列，此时队列会将收到的消息将以轮询的方式分发给所有的消费者，即每条消息只会发送给一个消费者，不会出现一条消息被多个消费者重复消费的情况。<br>Consumer：消费者，订阅需要的队列，并负责消费存储在队列中的消息。为了保证消息能够从队列可靠的到达消费者，RabbitMQ 提供了消息确认机制，并通过 autoAck 参数来进行控制：true 消息发送出去（写入TCP套接字）后就认为消费成功，而不管消费者是真正消费到这些消息。当 TCP 连接或者c hannel 因意外关闭，或者消费者在消费过程中以外宕机时，对应的消息就丢失。因此，这种模式可以提高吞吐量，但是存在数据丢失的风险。<br>Connection：用于传递消息的TCP连接。<br>Channel：消息通道，在客户端的每个连接里，可建立多个 channel，每个channel代表一个会话任务。RabbitMQ 采用类似 NIO (非阻塞式IO )的设计，通过 Channel 来复用 TCP 连接，并确保每个 Channel 的隔离性，就像是拥有独立的 Connection 连接。当数据流量不是很大时，采用连接复用技术可以避免创建过多的 TCP 连接而导致昂贵的性能开销。<br> Virtual Host：虚拟主机，一个 broker 里可以开设多个 vhost，用作不同用户的权限分离。RabbitMQ 通过虚拟主机来实现逻辑分组和资源隔离，一个虚拟主机就是一个小型的 RabbitMQ 服务器，拥有独立的队列、交换器和绑定关系。用户可以按照不同业务场景建立不同的虚拟主机，虚拟主机之间是完全独立的，你无法将 vhost1 上的交换器与 vhost2 上的队列进行绑定，这可以极大的保证业务之间的隔离性和数据安全，默认的虚拟主机名为&#x2F;。<br>Broker：消息队列服务器实体。</p><h1 id="RabbitMQ-安装"><a href="#RabbitMQ-安装" class="headerlink" title="RabbitMQ 安装"></a>RabbitMQ 安装</h1><p>使用 docker 安装：</p><ol><li>查询镜像：docker search rabbitmq:management</li></ol><p>management 表示有管理页面的版本</p><ol start="2"><li>获取镜像：docker pull rabbitmq:management</li><li>启动镜像：docker run -d -p 5672:5672 -p 15672:15672 –name rabbitmq rabbitmq:management</li><li>关闭防火墙：</li></ol><p>systemctl stop firewalld<br>systemctl disable firewalld</p><ol start="5"><li>访问管理页面：<a href="http://ip:15672，用户名密码均">http://ip:15672，用户名密码均</a> guest</li><li>创建用户（可选）<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ9.png" alt="image.png"></li></ol><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>RabbitMQ 如果生产者创建了消息但是没有对应的队列，默认会直接丢弃。队列是由消费者创建的。</p><h2 id="直连模式"><a href="#直连模式" class="headerlink" title="直连模式"></a>直连模式</h2><p>直连模式下，两个消费者绑定 Key 相同，队列相同会轮询拿消息，队列不同会都收到全部消息。队列相同，绑定 key 是否相同都会轮询拿消息。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ10.png" alt="image.png"><br>总之记住一句，<strong>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应绑定键的队列</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连模式服务端示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProducerDirect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//交换器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">//路由键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">route_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建连接工厂，连接RabbitMQ</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.在信道中设置交换器，指定模式为直连</span></span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//5.交换器和队列绑定放到消费者进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello rabbitMQ ,i am &quot;</span> + i;</span><br><span class="line">            <span class="comment">//消息进行发送</span></span><br><span class="line">            channel.basicPublish(exchange_name, route_key, <span class="literal">false</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;rabbitMQ send message key:【&quot;</span> + route_key + <span class="string">&quot;】,message【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.关闭信道，关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连模式客户端示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDirect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//交换器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">//队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_queue&quot;</span>;</span><br><span class="line">        <span class="comment">//绑定key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建连接工厂，连接RabbitMQ</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.在信道中设置交换器</span></span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//5.声明队列</span></span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//6.交换器和队列绑定</span></span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        <span class="comment">//绑定多个key</span></span><br><span class="line">        <span class="comment">//channel.queueBind(DIRECT_QUEUE, EXCHANGE_NAME, &quot;key3&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="comment">//7.声明消费者</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//8.消费者在指定的对队列上消费</span></span><br><span class="line">        <span class="comment">//true 代表是否自动提交</span></span><br><span class="line">        <span class="comment">//queue_name 消费数据的队列</span></span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连模式客户端示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDirect2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//交换器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">//队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_queue_99&quot;</span>;</span><br><span class="line">        <span class="comment">//绑定key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建连接工厂，连接RabbitMQ</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.在信道中设置交换器</span></span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//5.声明队列</span></span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//6.交换器和队列绑定</span></span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        <span class="comment">//绑定多个key</span></span><br><span class="line">        <span class="comment">//channel.queueBind(DIRECT_QUEUE, EXCHANGE_NAME, &quot;key3&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="comment">//7.声明消费者</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//8.消费者在指定的对队列上消费</span></span><br><span class="line">        <span class="comment">//true 代表是否自动提交</span></span><br><span class="line">        <span class="comment">//queue_name 消费数据的队列</span></span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--添加rabbitMQ客户端--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="扇形模式"><a href="#扇形模式" class="headerlink" title="扇形模式"></a>扇形模式</h2><p>生产者和消费者之间根据交换器关联，只要交换器一样，不管路由 key 和绑定 key 是否一样。多个消费者，如果队列名一样则轮询获得消息，如果队列名不一样则都收到消息。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ11.png" alt="image.png"><br>channel.exchangeDeclare(exchange_name, BuiltinExchangeType.FANOUT);</p><h2 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h2><p>生产者和消费者之间交换器一致，多个消费者的队列需不一样，如果一样则会出现乱消费数据情况（原因待深入研究）。路由 key 和绑定 key 存在模糊关系。比如消费者A的绑定 key 是 send.* 表示匹配 send 开头的后面有一个单词的路由 key 发送的消息；*.sms.*表示一个单词.sms.一个单词；#.num 表示匹配 num 前有若干个单词的路由 key。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ12.png" alt="image.png"><br>约束条件：</p><ul><li>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li><li>routing key为一个句点号“.”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”，binding key 与 routing key 一样也是句点号“.”分隔的字符串</li></ul><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的多消费者&#x2F;多应用（multiple consumers&#x2F;applications）的时候，主题交换机都可以被列入考虑范围。<br>常见使用场景：</p><ul><li>分发有关于特定地理位置的数据，例如销售点</li><li>由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务</li><li>股票价格更新（以及其他类型的金融数据更新）</li><li>涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）</li><li>云端的不同种类服务的协调</li><li>分布式架构&#x2F;基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统</li></ul><p>channel.exchangeDeclare(exchange_name, BuiltinExchangeType.TOPIC);</p><h2 id="头部模式（不常用）"><a href="#头部模式（不常用）" class="headerlink" title="头部模式（不常用）"></a>头部模式（不常用）</h2><blockquote><p>headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</p></blockquote><p>头交换机可以视为直连交换机的另一种表现形式。但直连交换机的路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。灵活性更强（但实际上我们很少用到头交换机）。<br>工作流程：</p><ol><li>绑定一个队列到头交换机上时，会同时绑定多个用于匹配的头（header）</li><li>传来的消息会携带header，以及会有一个 “x-match” 参数。当 “x-match” 设置为 “any” 时，消息头的任意一个值被匹配就可以满足条件，而当 “x-match” 设置为 “all” 的时候，就需要消息头的所有值<br>都匹配成功</li></ol><h1 id="交换器小结"><a href="#交换器小结" class="headerlink" title="交换器小结"></a>交换器小结</h1><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ13.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 源码学习 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat源码剖析（更新中）</title>
      <link href="/2023/07/04/tomcat%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2023/07/04/tomcat%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat-整体架构剖析"><a href="#Tomcat-整体架构剖析" class="headerlink" title="Tomcat 整体架构剖析"></a>Tomcat 整体架构剖析</h1><h2 id="Tomcat-的核心能力"><a href="#Tomcat-的核心能力" class="headerlink" title="Tomcat 的核心能力"></a>Tomcat 的核心能力</h2><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/tomcat1.png" alt="1688451755541"></p><p>从上图中可以看出主要是，接收请求、调用业务类、回写响应。</p><p>如何统一开发者写的业务类？定规范，做抽象。例如 JAVA EE：javax.servlet.Servlet，该规范定义了开发者如何编写业务类处理 web 请求。</p><p>如此一来就可以得到如下图的功能设计</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/tomcat2.png" alt="1688457645620"></p><p>tomcat 功能</p><ul><li>http 服务器功能：处理底层的网络通信，应用层协议解析等相关功能</li><li>Servlet 容器功能：Servlet 的管理、加载、调用等</li></ul><p>Tomcat 核心功能流程总结</p><ol><li>监听网络端口，接收客户端连接</li><li>接受网络连接请求，读取网络请求字节流</li><li>根据具体应用层协议（HTTP）解析字节流，最终生成标准的 ServletRequest 对象</li><li>调用 Servlet 容器，得到标准的 ServletResponse 数据</li><li>最终将 ServletResponse 数据转换成网络字节流</li><li>将响应字节流回写给浏览器</li></ol><h2 id="Tomcat-的整体架构-组件分析"><a href="#Tomcat-的整体架构-组件分析" class="headerlink" title="Tomcat 的整体架构-组件分析"></a>Tomcat 的整体架构-组件分析</h2><p>连接器 Connector 对外处理请求，涉及的关键要素：IO 模型（例如：NIO、NIO2、APR）；应用协议（http&#x2F;1.1、AJP、http&#x2F;2）。IO 模型和应用协议可以组合，于是就会有多个连接器。</p><p>容器 Container 对内管理 Servlet。</p><p>如何管理连接器和容器？引入 Service 组件进行连接器和容器的管理。</p><p>Server：最顶层组件，代表一个 tomcat 实例。</p><p>组件结构可查看 tomcat 源码的核心配置文件：server.xml</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/tomcat3.png" alt="1688472991861"></p><h3 id="核心组件相关类和接口"><a href="#核心组件相关类和接口" class="headerlink" title="核心组件相关类和接口"></a>核心组件相关类和接口</h3><ul><li>Connector 类：org.apache.catalina.connector.Connector</li><li>Container 接口：org.apache.catalina.Container</li><li>Server 接口：org.apache.catalina.Server</li><li>Service 接口：org.apache.catalina.Service</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 源码学习 </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/25/hello-world/"/>
      <url>/2023/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
