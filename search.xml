<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ深度解析（下）</title>
      <link href="/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h1><h2 id="什么是延时任务"><a href="#什么是延时任务" class="headerlink" title="什么是延时任务"></a>什么是延时任务</h2><p>延时任务不是定时任务，需有前置条件。比如生成订单30min未支付，则自动取消。前置条件是下单。定时任务则不需要有前置条件，到点或按频率执行就行。</p><h2 id="和定时任务的区别"><a href="#和定时任务的区别" class="headerlink" title="和定时任务的区别"></a>和定时任务的区别</h2><ol><li>定时任务有明确的触发时间，延时任务没有</li><li>定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期</li><li>定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务</li></ol><h2 id="延时队列使用场景"><a href="#延时队列使用场景" class="headerlink" title="延时队列使用场景"></a>延时队列使用场景</h2><ul><li>订单在十分钟之内未支付则自动取消</li><li>账单在一周内未支付，则自动结算</li><li>用户注册成功后，如果没有修改初始密码进行提醒</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li><li>等</li></ul><p>规范建议：数据库中如果时间字段经常排序、查询操作建议存 long 值，效率更快。原因是2023-09-01这种在查询和排序时，数据库也是转为 long 值后再进行操作。</p><h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><h3 id="数据库轮询（定时思想）"><a href="#数据库轮询（定时思想）" class="headerlink" title="数据库轮询（定时思想）"></a>数据库轮询（定时思想）</h3><p>该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行 update 或 delete 等操作。<br>优点：简单易行，支持集群操作，可快速上线。适用于项目前期数据量小的场景<br>缺点：对服务器内存消耗大；存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟；假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大</p><h3 id="JDK-的延迟队列"><a href="#JDK-的延迟队列" class="headerlink" title="JDK 的延迟队列"></a>JDK 的延迟队列</h3><p>该方案是利用 JDK 自带的 DelayQueue 来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入 DelayQueue 中的对象，是必须实现 Delayed 接口的。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-1.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK的延迟队列示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Tengbin Li </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/6/2 16:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkDelayDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        DelayQueue&lt;MyDelay&gt; delayQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>();</span><br><span class="line">        delayQueue.add(<span class="keyword">new</span> <span class="title class_">MyDelay</span>(<span class="string">&quot;A&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        delayQueue.add(<span class="keyword">new</span> <span class="title class_">MyDelay</span>(<span class="string">&quot;B&quot;</span>, <span class="number">11</span>, TimeUnit.SECONDS));</span><br><span class="line">        delayQueue.add(<span class="keyword">new</span> <span class="title class_">MyDelay</span>(<span class="string">&quot;C&quot;</span>, <span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//取延迟任务，使用take的好处：如果没有延迟任务会进行阻塞，防止while循环导致CPU压力过大</span></span><br><span class="line">            <span class="type">MyDelay</span> <span class="variable">take</span> <span class="operator">=</span> delayQueue.take();</span><br><span class="line">            take.excute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义延迟任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyDelay</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 延迟时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name      任务名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> startTime 延迟时间</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit      时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MyDelay(String name, <span class="type">long</span> startTime, TimeUnit unit) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//延迟时间转毫秒值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">convert</span> <span class="operator">=</span> TimeUnit.MILLISECONDS.convert(startTime, unit);</span><br><span class="line">            <span class="built_in">this</span>.startTime = currentTime + convert;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法作用是告诉jdk是否执行任务，0表示执行，非0表示多长时间后执行</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (startTime &lt;= currentTimeMillis) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//休息时间差值，需将毫秒转成用户指定的单位类型</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">convert</span> <span class="operator">=</span> unit.convert(startTime - currentTimeMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">return</span> convert;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 作用是：任务1 10s后执行，任务2 5s后执行。排序 将5s放在10s前</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">            <span class="comment">//前一个任务</span></span><br><span class="line">            <span class="type">MyDelay</span> <span class="variable">prx</span> <span class="operator">=</span> (MyDelay) o;</span><br><span class="line">            <span class="type">MyDelay</span> <span class="variable">next</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (prx.startTime &lt; next.startTime) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prx.startTime &gt; next.startTime) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//执行延迟</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;执行延迟任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点：效率高，任务触发时间延迟低。<br>缺点：服务器重启后，数据全部消失，怕宕机。集群扩展相当麻烦。内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常。代码复杂度较高。</p><h3 id="netty-时间轮算法"><a href="#netty-时间轮算法" class="headerlink" title="netty 时间轮算法"></a>netty 时间轮算法</h3><blockquote><p>时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick</p></blockquote><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-2.png" alt="image.png"><br>这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的 tick 数），tickDuration（一个 tick 的持续时间）以及 timeUnit（时间单位），例如当 ticksPerWheel&#x3D;60，tickDuration&#x3D;1，timeUnit&#x3D;秒，这就和现实中的始终的秒针走动完全类似了。</p><p>如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈，位置是在2圈之后的5上面（20 % 8 + 1）。</p><p>优点：效率高，任务触发时间延迟时间比 delayQueue 低，代码复杂度比 delayQueue 低。<br>缺点：服务器重启后，数据全部消失，怕宕机。集群扩展相当麻烦。因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常。</p><h3 id="使用消息队列"><a href="#使用消息队列" class="headerlink" title="使用消息队列"></a>使用消息队列</h3><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-3.png" alt="image.png"><br>我们可以采用 RabbitMQ 的延时队列，RabbitMQ 具有以下两个特性，可以实现延迟队列</p><ul><li>RabbitMQ 可以针对 Queue 和 Message 设置 x-message-ttl，来控制消息的生存时间，如果超时，则消息变为 dead letter。</li><li>RabbitMQ 的 Queue 可以配置 x-dead-letter-exchange 和 x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了 dead letter，则按照这两个参数重新路由。</li></ul><p>优点：高效，可以利用 rabbitmq 的分布式特性轻易的进行横向扩展，消息支持持久化增加了可靠性。<br>缺点：本身的易用度要依赖于 RabbitMQ 的运维，因为要引用 RabbitMq，所以复杂度和成本变高。</p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>RabbitMQ 中没有对消息延迟进行实现，但是我们可以通过 TTL 以及死信路由来实现消息延迟。<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-4.png" alt="image.png"><br>TTL 消息过期时间<br>TTL 是 RabbitMq 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果再 TTL 设置的时间内没有被消费，则会称为“死信”，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">taxiOverQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">30000</span>);</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(TAXI_OVER_QUEUE).withArguments(args).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理解<br>一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列。</p><p><strong>死信队列使用场景</strong></p><ul><li>消费者对消息使用了 basicReject 或者 basicNack 回复，并且 requeue 参数设置为 false ，即不再将该消息重新在消费者间进行投递</li><li>消息在队列中超时，RabbitMQ 可以在单个消息或者队列中设置 TTL 属性</li><li>队列中的消息已经超过其设置的最大消息个数</li></ul><p>死信交换器不是默认的设置，这里是被投递消息被拒绝后的一个可选行为，是在创建队列的时进行声明的，往往用在对问题消息的诊断上。<br>死信交换器仍然只是一个普通的交换器，创建时并没有特别要求和操作，在创建队列的时候，声明该交换器将用作保存被拒绝的消息即可，相关的参数是 x-dead-letter-exchange。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-5.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列示例服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProducerDelay</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">route_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_route&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> currentTime + <span class="string">&quot;--hello rabbitMQ ,i am &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(exchange_name, route_key, <span class="literal">false</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;rabbitMQ send message key:【&quot;</span> + route_key + <span class="string">&quot;】,message【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于给死信队列投递消息的正常队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDelay</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_delay_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; dlxMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置消息在延时队列等待时间 5s</span></span><br><span class="line">        dlxMap.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        dlxMap.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>);</span><br><span class="line">        <span class="comment">//死信路由键，会替换消息原来的路由键</span></span><br><span class="line">        dlxMap.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dead_key&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列，注意dlxMap</span></span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, dlxMap);</span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消费者在指定的对队列上消费，这里第三个参数为null，则不会消费消息等着超时放到死信队列上</span></span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.queuedelay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列消费者（就是一个普通的消费者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDlx</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;dlx_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_dlx_queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;dead_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="comment">//声明消费者</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">receiveTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(receiveTime + <span class="string">&quot;--rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>单独指定每一条的消息的延时时间</strong><br>有个特殊情况，假如第一条消息过期时间指定10s，第二条指定1s，则会等第一条超时消费完后才会消费第二条，所以第二条的延迟时间也是10s。但要是第一条1s，第二条10s，则到了1s后会消费第一条，10s后会第二条。<br>有点特殊，个人不太建议使用这种。这种需要在发消息时就根据业务类型区分了不同的延时时间，耦合度高。建议还是按照上面的根据业务指定不同的消费队列，在队列中根据业务设置统一的延时时间。<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-6.png" alt="image.png"><br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-7.png" alt="image.png"><br>注意：如果消息过期时间和队列过期时间同时存在，谁的过期时间短，则以谁为准。（个人建议直接不要给消息单独设置过期时间）</p><h1 id="RabbitMQ-消息可靠性保障"><a href="#RabbitMQ-消息可靠性保障" class="headerlink" title="RabbitMQ 消息可靠性保障"></a>RabbitMQ 消息可靠性保障</h1><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ-8.png" alt="image.png"><br>从上面的图可以看到，消息的投递有三个对象参与：</p><ul><li>生产者</li><li>broker</li><li>消费者</li></ul><h2 id="生产者保证"><a href="#生产者保证" class="headerlink" title="生产者保证"></a>生产者保证</h2><p>生产者发送消息到 broker 时，要保证消息的可靠性，主要的方案有以下2种：</p><ul><li>失败通知</li><li>发送方确认</li></ul><h3 id="失败通知"><a href="#失败通知" class="headerlink" title="失败通知"></a>失败通知</h3><p>如果出现消息无法投递到队列会出现失败通知。<br>mandatory&#x3D;true 消息发送时设置；内部类 ReturnListener 失败通知逻辑代码<br>注意：失败通知是能路由到队列则不发，不能路由到队列则发送。但是能路由到队列不代表消息能正常被消费，所以还有一个环节：发送方确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.sendconfirm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProducerConfirm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_confirm_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">route_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_confirm_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加失败通知监听，如果出现消息无法投递到队列会出现失败通知</span></span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> <span class="title class_">ReturnListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturn</span><span class="params">(<span class="type">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;失败通知--rabbitMQ sendConfirm replyCode:【&quot;</span> + replyCode + <span class="string">&quot;】,replyText:【&quot;</span> + replyText + <span class="string">&quot;】,exchange:【&quot;</span> + exchange + <span class="string">&quot;】,routingKey:【&quot;</span> + routingKey + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//交换器和队列绑定放到消费者进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello rabbitMQ ,i am &quot;</span> + i;</span><br><span class="line">            <span class="comment">//消息进行发送</span></span><br><span class="line">            <span class="comment">//mandatory=true，就是第三个参数</span></span><br><span class="line">            channel.basicPublish(exchange_name, route_key, <span class="literal">true</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;rabbitMQ send message key:【&quot;</span> + route_key + <span class="string">&quot;】,message【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            <span class="comment">//这里睡眠是为了保证服务端有时间可以收到失败通知</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送方确认"><a href="#发送方确认" class="headerlink" title="发送方确认"></a>发送方确认</h3><p>可路由：消息到达队列，并且队列保存消息成功（RabbitMQ 内部的逻辑，很难出现失败的情况）<br>不可路由：是否到达交换器，如果到达了交换器返回成功，没到达则失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用发送者确认模式</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//添加消息发送确认</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送方确认--消息发送成功，deliveryTag:&quot;</span> + deliveryTag + <span class="string">&quot;,multiple:&quot;</span> + multiple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送方确认--消息发送失败，deliveryTag:&quot;</span> + deliveryTag + <span class="string">&quot;,multiple:&quot;</span> + multiple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总结：<br>失败通知有，不管发送方确认是成功还是失败，结果都是失败。<br>失败通知没有，发送方确认是成功则成功，反之失败。</p><h2 id="broker-保证"><a href="#broker-保证" class="headerlink" title="broker 保证"></a>broker 保证</h2><h3 id="交换器持久化"><a href="#交换器持久化" class="headerlink" title="交换器持久化"></a>交换器持久化</h3><p>交换器持久化后，即便 RabbitMq 宕机重启后仍存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在信道中设置交换器 服务端</span></span><br><span class="line">channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在信道中设置交换器 消费端</span></span><br><span class="line">channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>队列持久化，即便 RabbitMq 宕机重启后仍存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明队列 第二个参数true</span></span><br><span class="line">channel.queueDeclare(queue_name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>发送消息时设置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = new AMQP.</span><br><span class="line">        BasicProperties.</span><br><span class="line">        Builder().</span><br><span class="line">//2表示持久化，1非持久化</span><br><span class="line">        deliveryMode(2).</span><br><span class="line">        build();</span><br><span class="line">//消息进行发送 第四个参数</span><br><span class="line">channel.basicPublish(exchange_name, route_key, true, properties, message.getBytes(&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure><p>注意消息持久化的前提时交换器和队列进行了持久化</p><h2 id="消费方保证"><a href="#消费方保证" class="headerlink" title="消费方保证"></a>消费方保证</h2><p>消费者接收到消息，但是还未处理或者还未处理完，此时消费者进程挂掉了，比如重启或者异常断电等，此时 mq 认为消费者已经完成消息消费，就会从队列中删除消息，从而导致消息丢失。<br>那该如何避免这种情况呢？这就要用到 RabbitMQ 提供的 ack 机制，RabbitMQ 默认是自动 ack 的，此时需要将其修改为手动 ack，也即自己的程序确定消息已经处理完成后，手动提交 ack，此时如果再遇到消息未处理进程就挂掉的情况，由于没有提交 ack，RabbitMQ 就不会删除这条消息，而是会把这条消息发送给其他消费者处理，但是消息是不会丢的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Consumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">        String message = new String(body, &quot;utf-8&quot;);</span><br><span class="line">        System.out.println(&quot;rabbitMQ receive message key:【&quot; + envelope.getRoutingKey() + &quot;】;message:【&quot; + message + &quot;】&quot;);</span><br><span class="line">int i = (int) (Math.random() * 10);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">//模拟出现问题</span><br><span class="line">        if (i % 2 != 0) &#123;</span><br><span class="line">            //失败时。参数1哪条消息、参数2是否批量nack、参数3是否重回队列</span><br><span class="line">            channel.basicNack(envelope.getDeliveryTag(), false, true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //成功时。参数1哪条消息、参数2是否批量ack</span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般业务上假如消息进行了5次nack后，可将消息不再重回队列，放入死信或数据库，进行告警。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 源码学习 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ深度解析（上）</title>
      <link href="/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/07/04/RabbitMQ%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="消息中间件（MQ）"><a href="#消息中间件（MQ）" class="headerlink" title="消息中间件（MQ）"></a>消息中间件（MQ）</h1><h2 id="消息队列回顾"><a href="#消息队列回顾" class="headerlink" title="消息队列回顾"></a>消息队列回顾</h2><blockquote><p>消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实<br>现高性能，高可用，可伸缩和最终一致性架构</p></blockquote><p>目前使用较多的消息队列有 ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ，消<br>息中间件到底该如何使用，何时使用这是一个问题，胡乱地使用消息中间件增加了系统的复杂度，如果<br>用不好消息中间件还不如不用。<br>消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式<br>系统的集成，通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信，对于消息<br>中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）。</p><h2 id="消息队列特点"><a href="#消息队列特点" class="headerlink" title="消息队列特点"></a>消息队列特点</h2><ol><li>先进先出：先进先出是队列的一个特性，数据是只有一条数据在使用中。</li><li>订阅：一般是 MQ 的广播模式，类似于 Java 的观察者模式，发布订阅是一种高效的处理方式，如果不发生阻塞，基本可以当作是同步操作。</li><li>持久化：MQ 能像数据库一样存储核心的数据。</li><li>分布式：在现在大流量、大数据的使用场景下，只支持单体应用的服务器软件基本是无法使用的，支持分布式的部署，才能被广泛使用，而且，MQ的定位就是一个高性能的中间件。</li></ol><h2 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a>为什么使用消息队列？</h2><p>解耦、异步、削峰</p><ol><li>解耦：举例快递业务。传统做法需要依次执行快递投柜，扣减费用，通知用户，通知快递公司，如果其中某一步异常（例如用户手机未开机或者快递公司接口故障），将会延迟甚至中断整个投柜流程，严重影响用户体验。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ1.png" alt="image.png">如果接口层收到投柜数据后，写入消息到 MQ，后续三个子系统各自消费处理，将可以完美解决该问题，并且子系统故障不影响上游系统！此为解耦！</li><li>异步：比如快递投柜后，用户马上就结束了，不会等待到发送短信或者通知快递公司结束的，直接将消息投递到 MQ，然后就直接结束，具体到扣减系统费以及后续的通知，都是异步操作的，不需要用户关心的，这就是将用户的同步操作转换为异步操作。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ2.png" alt="image.png">如果全部同步操作需要15s，而发送到 MQ 后交给系统异步处理用户只需要1s就可以完成操作。</li><li>流量削峰：就像用户投递快递，高峰到40W每秒，但是我们的后续处理业务每秒只能20W，还剩下20W在 MQ 进行堆积，这就是MQ很重要的流量削峰的能力，将用户的洪峰流量，让后台慢慢来处理，MQ 承担一个缓冲的作用。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ3.png" alt="image.png">就像这个波形图一样，如果用户请求的并发量的最高峰时40W，系统的承载能力只能达到30W，就可以使用MQ进行削峰，将系统最高40W的并发削峰为最高只有20万，就是时间换空间的做法。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ4.png" alt="image.png"></li></ol><h2 id="消息队列有什么缺点？"><a href="#消息队列有什么缺点？" class="headerlink" title="消息队列有什么缺点？"></a>消息队列有什么缺点？</h2><ol><li>系统可用性降低：我们投递快递，如果 MQ 出现问题，那么我们整个系统调用链路就会断开，前后端将无法通讯。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ5.png" alt="image.png"></li><li>系统复杂性提高：在使用消息队列的过程中，难免会出现生产者、MQ、消费者宕机不可用的情况，那么随之带来的问题就是消息重复、消息乱序、消息堆积等等问题都需要我们来控制。</li><li>一致性问题：如下图所示，系统需要保证快递投递，扣减系统费，通知等之间的数据一致性，如果系统短信通知，快递通知执行成功，扣减系统费执行失败时，就会出现数据不一致问题。应对方案，比如重试等方案。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ6.png" alt="image.png"></li></ol><h2 id="消息队列通讯模式"><a href="#消息队列通讯模式" class="headerlink" title="消息队列通讯模式"></a>消息队列通讯模式</h2><ol><li>点对点通讯：支持一对一，一对多，多对一，多对多。</li><li>发布&#x2F;订阅：</li><li>群集：为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster（群集）的解决方案。群集类似于一个域（Domain），群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集（Cluster）通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li></ol><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>RabbitMQ是流行的开源消息队列系统，用 erlang 语言开发，RabbitMQ 是 AMQP（高级消息队列协议）的标准实现。</p></blockquote><p>特性：</p><ul><li>erlang 语言开发，性能极其好，延时很低</li><li>吞吐量到万级，MQ功能比较完备</li><li>开源提供的管理界面非常棒，用起来很好用</li><li>社区相对比较活跃</li></ul><h1 id="怎样选择MQ？"><a href="#怎样选择MQ？" class="headerlink" title="怎样选择MQ？"></a>怎样选择MQ？</h1><p>横向对比<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ7.png" alt="image.png"></p><p>个人建议</p><ul><li>中小型公司，技术一般，可以考虑用 RabbitMQ。</li><li>大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>实时计算、日志采集：使用 kafka。</li></ul><p>如何选型</p><ul><li>RabbitMQ：erlang 开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降，每秒钟可以处理几万到十几万条消息。</li><li>RocketMQ：java 开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒钟大概能处理几十万条消息。</li><li>Kafka：Scala 开发，面向日志功能丰富，性能最高，当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高，所以，Kafka 不太适合在线业务场景。</li></ul><h1 id="RabbitMQ-基本使用"><a href="#RabbitMQ-基本使用" class="headerlink" title="RabbitMQ 基本使用"></a>RabbitMQ 基本使用</h1><p>RabbitMQ 与 AMQP 遵循相同的模型架构，其架构示例图如下<br><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ8.png" alt="image.png"><br><strong>Publisher</strong>：消费生产者，就是投递消息的程序，负责生产消息并将其投递到指定的交换器上。<br><strong>Message</strong>：消息，消息由消息头和消息体组成，消息头用于存储与消息相关的元数据：如目标交换器的名字（exchange_name）路由键（RountingKey）和其他可选配置（properties）信息。消息体为实际需要传递的数据。<br><strong>RountingKey</strong>：生产者将消息发给交换器的时候，一般会指定一个 RountingKey，用来指定这个消息的路由规则，当 RountingKey 与 BindingKey 基于交换器类型的规则相匹配时，消息将被路由到对应的队列中。<br>Exchange：交换器，负责接收来自生产者的消息，并将消息路由到一个或者多个队列中，如果路由不到，则返回给生产者或者直接丢弃，这取决于交换器的 mandatory 属性：true 返回给生产者，false 直接丢弃。<br>BindingKey：绑定 Key，交换器与队列通过 BindingKey 建立绑定关系。<br>Queue：消息队列载体，每个消息都会被投入到一个或者多个队列。用于存储路由过来的消息，多个消费者可以订阅同一个消息队列，此时队列会将收到的消息将以轮询的方式分发给所有的消费者，即每条消息只会发送给一个消费者，不会出现一条消息被多个消费者重复消费的情况。<br>Consumer：消费者，订阅需要的队列，并负责消费存储在队列中的消息。为了保证消息能够从队列可靠的到达消费者，RabbitMQ 提供了消息确认机制，并通过 autoAck 参数来进行控制：true 消息发送出去（写入TCP套接字）后就认为消费成功，而不管消费者是真正消费到这些消息。当 TCP 连接或者c hannel 因意外关闭，或者消费者在消费过程中以外宕机时，对应的消息就丢失。因此，这种模式可以提高吞吐量，但是存在数据丢失的风险。<br>Connection：用于传递消息的TCP连接。<br>Channel：消息通道，在客户端的每个连接里，可建立多个 channel，每个channel代表一个会话任务。RabbitMQ 采用类似 NIO (非阻塞式IO )的设计，通过 Channel 来复用 TCP 连接，并确保每个 Channel 的隔离性，就像是拥有独立的 Connection 连接。当数据流量不是很大时，采用连接复用技术可以避免创建过多的 TCP 连接而导致昂贵的性能开销。<br> Virtual Host：虚拟主机，一个 broker 里可以开设多个 vhost，用作不同用户的权限分离。RabbitMQ 通过虚拟主机来实现逻辑分组和资源隔离，一个虚拟主机就是一个小型的 RabbitMQ 服务器，拥有独立的队列、交换器和绑定关系。用户可以按照不同业务场景建立不同的虚拟主机，虚拟主机之间是完全独立的，你无法将 vhost1 上的交换器与 vhost2 上的队列进行绑定，这可以极大的保证业务之间的隔离性和数据安全，默认的虚拟主机名为&#x2F;。<br>Broker：消息队列服务器实体。</p><h1 id="RabbitMQ-安装"><a href="#RabbitMQ-安装" class="headerlink" title="RabbitMQ 安装"></a>RabbitMQ 安装</h1><p>使用 docker 安装：</p><ol><li>查询镜像：docker search rabbitmq:management</li></ol><p>management 表示有管理页面的版本</p><ol start="2"><li>获取镜像：docker pull rabbitmq:management</li><li>启动镜像：docker run -d -p 5672:5672 -p 15672:15672 –name rabbitmq rabbitmq:management</li><li>关闭防火墙：</li></ol><p>systemctl stop firewalld<br>systemctl disable firewalld</p><ol start="5"><li>访问管理页面：<a href="http://ip:15672，用户名密码均">http://ip:15672，用户名密码均</a> guest</li><li>创建用户（可选）<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ9.png" alt="image.png"></li></ol><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>RabbitMQ 如果生产者创建了消息但是没有对应的队列，默认会直接丢弃。队列是由消费者创建的。</p><h2 id="直连模式"><a href="#直连模式" class="headerlink" title="直连模式"></a>直连模式</h2><p>直连模式下，两个消费者绑定 Key 相同，队列相同会轮询拿消息，队列不同会都收到全部消息。队列相同，绑定 key 是否相同都会轮询拿消息。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ10.png" alt="image.png"><br>总之记住一句，<strong>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应绑定键的队列</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连模式服务端示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProducerDirect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//交换器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">//路由键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">route_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建连接工厂，连接RabbitMQ</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.在信道中设置交换器，指定模式为直连</span></span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//5.交换器和队列绑定放到消费者进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello rabbitMQ ,i am &quot;</span> + i;</span><br><span class="line">            <span class="comment">//消息进行发送</span></span><br><span class="line">            channel.basicPublish(exchange_name, route_key, <span class="literal">false</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;rabbitMQ send message key:【&quot;</span> + route_key + <span class="string">&quot;】,message【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.关闭信道，关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连模式客户端示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDirect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//交换器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">//队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_queue&quot;</span>;</span><br><span class="line">        <span class="comment">//绑定key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建连接工厂，连接RabbitMQ</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.在信道中设置交换器</span></span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//5.声明队列</span></span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//6.交换器和队列绑定</span></span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        <span class="comment">//绑定多个key</span></span><br><span class="line">        <span class="comment">//channel.queueBind(DIRECT_QUEUE, EXCHANGE_NAME, &quot;key3&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="comment">//7.声明消费者</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//8.消费者在指定的对队列上消费</span></span><br><span class="line">        <span class="comment">//true 代表是否自动提交</span></span><br><span class="line">        <span class="comment">//queue_name 消费数据的队列</span></span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.yongheng.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连模式客户端示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tengbin Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumerDirect2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//交换器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">//队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue_name</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_queue_99&quot;</span>;</span><br><span class="line">        <span class="comment">//绑定key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">binding_key</span> <span class="operator">=</span> <span class="string">&quot;rabbit_direct_route&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建连接工厂，连接RabbitMQ</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.23.199&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.在信道中设置交换器</span></span><br><span class="line">        channel.exchangeDeclare(exchange_name, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//5.声明队列</span></span><br><span class="line">        channel.queueDeclare(queue_name, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//6.交换器和队列绑定</span></span><br><span class="line">        channel.queueBind(queue_name, exchange_name, binding_key);</span><br><span class="line">        <span class="comment">//绑定多个key</span></span><br><span class="line">        <span class="comment">//channel.queueBind(DIRECT_QUEUE, EXCHANGE_NAME, &quot;key3&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待 message.....&quot;</span>);</span><br><span class="line">        <span class="comment">//7.声明消费者</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;rabbitMQ receive message key:【&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;】;message:【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//8.消费者在指定的对队列上消费</span></span><br><span class="line">        <span class="comment">//true 代表是否自动提交</span></span><br><span class="line">        <span class="comment">//queue_name 消费数据的队列</span></span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--添加rabbitMQ客户端--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="扇形模式"><a href="#扇形模式" class="headerlink" title="扇形模式"></a>扇形模式</h2><p>生产者和消费者之间根据交换器关联，只要交换器一样，不管路由 key 和绑定 key 是否一样。多个消费者，如果队列名一样则轮询获得消息，如果队列名不一样则都收到消息。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ11.png" alt="image.png"><br>channel.exchangeDeclare(exchange_name, BuiltinExchangeType.FANOUT);</p><h2 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h2><p>生产者和消费者之间交换器一致，多个消费者的队列需不一样，如果一样则会出现乱消费数据情况（原因待深入研究）。路由 key 和绑定 key 存在模糊关系。比如消费者A的绑定 key 是 send.* 表示匹配 send 开头的后面有一个单词的路由 key 发送的消息；*.sms.*表示一个单词.sms.一个单词；#.num 表示匹配 num 前有若干个单词的路由 key。<img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ12.png" alt="image.png"><br>约束条件：</p><ul><li>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li><li>routing key为一个句点号“.”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”，binding key 与 routing key 一样也是句点号“.”分隔的字符串</li></ul><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的多消费者&#x2F;多应用（multiple consumers&#x2F;applications）的时候，主题交换机都可以被列入考虑范围。<br>常见使用场景：</p><ul><li>分发有关于特定地理位置的数据，例如销售点</li><li>由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务</li><li>股票价格更新（以及其他类型的金融数据更新）</li><li>涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）</li><li>云端的不同种类服务的协调</li><li>分布式架构&#x2F;基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统</li></ul><p>channel.exchangeDeclare(exchange_name, BuiltinExchangeType.TOPIC);</p><h2 id="头部模式（不常用）"><a href="#头部模式（不常用）" class="headerlink" title="头部模式（不常用）"></a>头部模式（不常用）</h2><blockquote><p>headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</p></blockquote><p>头交换机可以视为直连交换机的另一种表现形式。但直连交换机的路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。灵活性更强（但实际上我们很少用到头交换机）。<br>工作流程：</p><ol><li>绑定一个队列到头交换机上时，会同时绑定多个用于匹配的头（header）</li><li>传来的消息会携带header，以及会有一个 “x-match” 参数。当 “x-match” 设置为 “any” 时，消息头的任意一个值被匹配就可以满足条件，而当 “x-match” 设置为 “all” 的时候，就需要消息头的所有值<br>都匹配成功</li></ol><h1 id="交换器小结"><a href="#交换器小结" class="headerlink" title="交换器小结"></a>交换器小结</h1><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/MQ%2FMQ13.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 源码学习 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat源码剖析（更新中）</title>
      <link href="/2023/07/04/tomcat%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2023/07/04/tomcat%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat-整体架构剖析"><a href="#Tomcat-整体架构剖析" class="headerlink" title="Tomcat 整体架构剖析"></a>Tomcat 整体架构剖析</h1><h2 id="Tomcat-的核心能力"><a href="#Tomcat-的核心能力" class="headerlink" title="Tomcat 的核心能力"></a>Tomcat 的核心能力</h2><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/tomcat1.png" alt="1688451755541"></p><p>从上图中可以看出主要是，接收请求、调用业务类、回写响应。</p><p>如何统一开发者写的业务类？定规范，做抽象。例如 JAVA EE：javax.servlet.Servlet，该规范定义了开发者如何编写业务类处理 web 请求。</p><p>如此一来就可以得到如下图的功能设计</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/tomcat2.png" alt="1688457645620"></p><p>tomcat 功能</p><ul><li>http 服务器功能：处理底层的网络通信，应用层协议解析等相关功能</li><li>Servlet 容器功能：Servlet 的管理、加载、调用等</li></ul><p>Tomcat 核心功能流程总结</p><ol><li>监听网络端口，接收客户端连接</li><li>接受网络连接请求，读取网络请求字节流</li><li>根据具体应用层协议（HTTP）解析字节流，最终生成标准的 ServletRequest 对象</li><li>调用 Servlet 容器，得到标准的 ServletResponse 数据</li><li>最终将 ServletResponse 数据转换成网络字节流</li><li>将响应字节流回写给浏览器</li></ol><h2 id="Tomcat-的整体架构-组件分析"><a href="#Tomcat-的整体架构-组件分析" class="headerlink" title="Tomcat 的整体架构-组件分析"></a>Tomcat 的整体架构-组件分析</h2><p>连接器 Connector 对外处理请求，涉及的关键要素：IO 模型（例如：NIO、NIO2、APR）；应用协议（http&#x2F;1.1、AJP、http&#x2F;2）。IO 模型和应用协议可以组合，于是就会有多个连接器。</p><p>容器 Container 对内管理 Servlet。</p><p>如何管理连接器和容器？引入 Service 组件进行连接器和容器的管理。</p><p>Server：最顶层组件，代表一个 tomcat 实例。</p><p>组件结构可查看 tomcat 源码的核心配置文件：server.xml</p><p><img src="https://bicycle808-blogs-1312817409.cos.ap-beijing.myqcloud.com/tomcat3.png" alt="1688472991861"></p><h3 id="核心组件相关类和接口"><a href="#核心组件相关类和接口" class="headerlink" title="核心组件相关类和接口"></a>核心组件相关类和接口</h3><ul><li>Connector 类：org.apache.catalina.connector.Connector</li><li>Container 接口：org.apache.catalina.Container</li><li>Server 接口：org.apache.catalina.Server</li><li>Service 接口：org.apache.catalina.Service</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 源码学习 </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/25/hello-world/"/>
      <url>/2023/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
